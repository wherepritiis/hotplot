<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AxiDraw Control Panel</title>
    <!-- Tachyons CSS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/tachyons@4.12.0/css/tachyons.min.css"
    />
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="/static/vendor/codemirror/codemirror.css" />
    <!-- CodeMirror Isotope Theme -->
    <link rel="stylesheet" href="/static/vendor/codemirror/theme/isotope.css" />
    <!-- Custom Styles -->
    <link rel="stylesheet" href="/static/styles.css" />
    <!-- AlpineJS Data Component - Define before Alpine loads -->
    <script>
      // Define Alpine component data function
      const appDataDefinition = () => ({
        currentMode: "plot",
        logPanelOpen: false,
        connected: false,
        plotting: false,
        paused: false,
        commandHistory: [],
        currentSvg: null,
        alerts: [],

        switchMode(mode) {
          this.currentMode = mode;
        },
        toggleLogPanel() {
          this.logPanelOpen = !this.logPanelOpen;
        },
        showAlert(message, type = "error") {
          const alert = {
            id: Date.now() + Math.random(),
            message: message,
            type: type, // "error", "success", "info", "warning"
          };
          this.alerts.push(alert);
          
          // Auto-dismiss after 5 seconds for errors, 3 seconds for others
          const dismissTime = type === "error" ? 5000 : 3000;
          setTimeout(() => {
            this.dismissAlert(alert.id);
          }, dismissTime);
        },
        dismissAlert(id) {
          this.alerts = this.alerts.filter(alert => alert.id !== id);
        },
        async connect() {
          try {
            window.log("Connecting...", "info");
            const response = await fetch("/connect", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
            });
            const result = await response.json();
            if (result.success) {
              window.log(result.message || "Connected successfully", "success");
              this.connected = true;
            } else {
              const errorMsg = result.error || "Connection failed";
              window.log(`Connection failed: ${errorMsg}`, "error");
              this.showAlert(`Connection Failed: ${errorMsg}`, "error");
              this.connected = false;
            }
            await window.checkState();
          } catch (error) {
            const errorMsg = error.message || "Connection error";
            window.log(`Error connecting: ${errorMsg}`, "error");
            this.showAlert(`Connection Error: ${errorMsg}`, "error");
            this.connected = false;
          }
        },
        async disconnect() {
          try {
            window.log("Disconnecting...", "info");
            const response = await fetch("/disconnect", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
            });
            const result = await response.json();
            if (result.success) {
              window.log(
                result.message || "Disconnected successfully",
                "success"
              );
              this.connected = false;
            } else {
              const errorMsg = result.error || "Disconnect failed";
              window.log(`Disconnect failed: ${errorMsg}`, "error");
              this.showAlert(`Disconnect Failed: ${errorMsg}`, "error");
            }
            await window.checkState();
          } catch (error) {
            const errorMsg = error.message || "Disconnect error";
            window.log(`Error disconnecting: ${errorMsg}`, "error");
            this.showAlert(`Disconnect Error: ${errorMsg}`, "error");
          }
        },
        async sendCommand() {
          const commandInput = document.getElementById("commandInput");
          const command = commandInput.value.trim();
          if (!command) {
            window.log("Please enter a command", "error");
            return;
          }
          if (!this.connected) {
            window.log("Not connected. Please connect first.", "error");
            return;
          }
          try {
            window.log(`Sending command: ${command}`, "info");
            const response = await fetch("/cmd", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ command: command }),
            });
            const result = await response.json();
            if (result.success) {
              window.log(
                result.message || "Command executed successfully",
                "success"
              );
              this.addToHistory(command, result.message || "Success");
            } else {
              const errorMsg = result.error || "Command failed";
              window.log(`Command failed: ${errorMsg}`, "error");
              this.showAlert(`Command Failed: ${errorMsg}`, "error");
              this.addToHistory(command, `Error: ${errorMsg}`);
            }
            commandInput.value = "";
          } catch (error) {
            const errorMsg = error.message || "Command error";
            window.log(`Error sending command: ${errorMsg}`, "error");
            this.showAlert(`Command Error: ${errorMsg}`, "error");
            this.addToHistory(command, `Error: ${errorMsg}`);
          }
        },
        addToHistory(command, response) {
          this.commandHistory.push({
            command,
            response,
            timestamp: new Date(),
          });
        },
        async copySvg() {
          try {
            let svgToCopy =
              this.currentSvg ||
              (typeof currentSvg !== "undefined" ? currentSvg : null);
            
            // If no SVG is available, generate it from the code editor
            if (!svgToCopy) {
              window.log("Generating SVG from code...", "info");
              
              // Get code from editor
              const code = codeEditor
                ? codeEditor.getValue()
                : document.getElementById("codeEditor").value;
              
              // Generate SVG
              svgToCopy = await generateSvgFromCode(code);
              
              // Store the generated SVG
              currentSvg = svgToCopy;
              this.currentSvg = svgToCopy;
            }
            
            // Copy to clipboard
            await navigator.clipboard.writeText(svgToCopy);
            window.log("SVG copied to clipboard", "success");
          } catch (error) {
            window.log(`Error copying SVG: ${error.message}`, "error");
          }
        },
      });
    </script>
    <!-- AlpineJS - Load without defer to ensure proper initialization order -->
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <!-- Register Alpine data immediately after Alpine loads -->
    <script>
      // Register Alpine data component - Alpine is now loaded
      Alpine.data("appData", appDataDefinition);
    </script>
    <!-- p5.js and p5.plotSvg will be loaded dynamically in preview iframe -->
  </head>
  <body
    x-data="appData"
    class="sans-serif w-100 center pa3"
  >
    <div class="app-container">
    <!-- Alert Notifications -->
    <div class="alert-container">
      <div class="alert-container-inner">
        <template x-for="alert in alerts" :key="alert.id">
          <div
            x-show="alerts.length > 0"
            x-transition:enter="transition ease-out duration-300"
            x-transition:enter-start="opacity-0 transform translate-y-[-10px]"
            x-transition:enter-end="opacity-100 transform translate-y-0"
            x-transition:leave="transition ease-in duration-200"
            x-transition:leave-start="opacity-100 transform translate-y-0"
            x-transition:leave-end="opacity-0 transform translate-y-[-10px]"
            :class="{
              'alert-error': alert.type === 'error',
              'alert-success': alert.type === 'success',
              'alert-info': alert.type === 'info',
              'alert-warning': alert.type === 'warning'
            }"
            class="alert"
          >
            <span x-text="alert.message" class="flex-auto pr2"></span>
            <button
              @click="dismissAlert(alert.id)"
              class="alert-dismiss"
              title="Dismiss"
            >
              ×
            </button>
          </div>
        </template>
      </div>
    </div>

    <!-- Header -->
    <header class="app-header">
      <!-- Logo (Left) -->
      <div class="app-logo">
        <span class="logo-text">Hotplot</span>
      </div>

      <!-- Mode Toggle Group (Center) -->
      <div class="mode-toggle-group">
        <div class="mode-toggle-container">
          <div 
            class="mode-toggle-slider"
            :style="currentMode === 'plot' ? 'transform: translateX(0%)' : 'transform: translateX(100%)'"
          ></div>
          <button
            @click="switchMode('plot')"
            :class="currentMode === 'plot' ? 'mode-toggle-btn-active' : 'mode-toggle-btn-inactive'"
            class="mode-toggle-btn"
          >
            Plot mode
          </button>
          <button
            @click="switchMode('interactive')"
            :class="currentMode === 'interactive' ? 'mode-toggle-btn-active' : 'mode-toggle-btn-inactive'"
            class="mode-toggle-btn"
          >
            Interactive mode
          </button>
        </div>
      </div>

      <!-- Connection Controls (Right) -->
      <div class="flex items-center">
        <div class="flex items-center mr3">
          <span class="mr2 f6 toggle-label" x-text="connected ? 'Disconnect' : 'Connect'"></span>
          <label class="toggle-switch">
            <input
              type="checkbox"
              :checked="connected"
              @change="connected ? disconnect() : connect()"
            />
            <span class="toggle-slider"></span>
          </label>
        </div>
        <span class="mr2 f6 text-muted">Status</span>
        <div
          :class="connected ? 'status-indicator-connected' : 'status-indicator-disconnected'"
          class="status-indicator mr3"
          id="statusIndicator"
        ></div>
        <span class="divider">|</span>
        <button
          @click="toggleLogPanel()"
          class="btn btn-icon"
        >
          Log
        </button>
      </div>
    </header>

    <!-- Plot Mode Content -->
    <div x-show="currentMode === 'plot'">
      <div class="flex">
        <!-- Left Column: Editor + Plot Settings + Buttons -->
        <div class="w-50 pr2">
          <!-- Perspective Box Code Editor -->
          <div class="perspective-box-container mb3">
              <div class="perspective-box">
                <!-- Box Faces -->
                <div class="box-face box-face-front"></div>
                <div class="box-face box-face-top"></div>
                <div class="box-face box-face-left"></div>
                
                <!-- Content -->
                <div class="box-content">
                  <!-- CodeMirror Editor -->
                  <div class="box-editor-container">
                    <textarea id="codeEditor" class="box-editor-textarea">function setup() {
  createCanvas(780, 560); // 8.125" x 5.83" at 96 dpi
  background(255);
  noFill();
}

function draw() {
  square(50, 100, 40);
}</textarea>
                  </div>
                </div>
                
                <!-- Circular Element -->
                <div class="circle-container">
                  <div class="circle-element" onclick="runPreview()">
                    <span class="circle-text">preview</span>
                  </div>
                  <!-- Curved Text Around Circle -->
                  <div class="curved-text">
                    <svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                      <defs>
                        <!-- Paths concentric with purple circle -->
                        <!-- Purple circle center is at (100, 100) in this coordinate system -->
                        <!-- Circle radius is 60px, text path radius is 85px for spacing -->
                        <!-- p5.js: from 1 o'clock to 5 o'clock -->
                        <path id="circle-path-p5js" d="M 100,15 A 85,85 0 0,1 185,100" fill="none"/>
                        <!-- sketch: from 5 o'clock to 11 o'clock (with gap at top) -->
                        <path id="circle-path-sketch" d="M 185,100 A 85,85 0 0,1 15,100" fill="none"/>
                      </defs>
                      <text font-size="18" fill="#A601F4" letter-spacing="0.15em">
                        <textPath href="#circle-path-p5js" startOffset="0%">
                          p 5 . j s
                        </textPath>
                      </text>
                      <text font-size="18" fill="#A601F4" letter-spacing="0.15em">
                        <textPath href="#circle-path-sketch" startOffset="0%">
                          s k e t c h
                        </textPath>
                      </text>
                    </svg>
                  </div>
                </div>
              </div>
            </div>
          
          <div class="panel">

            <div class="panel-section">
              <label for="layerInput" class="input-label"
                >Layer Number (optional)</label
              >
              <input
                type="number"
                id="layerInput"
                placeholder="Leave empty for all layers"
                class="input-field"
              />
            </div>

            <!-- Plot Settings Grid (2x2) -->
            <div class="panel-section">
              <div class="input-grid">
                <div class="input-grid-item">
                  <label for="penUp" class="input-label"
                    >Pen Up Height</label
                  >
                  <input
                    type="number"
                    id="penUp"
                    value="70"
                    min="0"
                    max="100"
                    class="input-field"
                  />
                </div>
                <div class="input-grid-item">
                  <label for="penDown" class="input-label"
                    >Pen Down Height</label
                  >
                  <input
                    type="number"
                    id="penDown"
                    value="40"
                    min="0"
                    max="100"
                    class="input-field"
                  />
                </div>
              </div>
            </div>

            <div class="panel-section">
              <div class="input-grid">
                <div class="input-grid-item">
                  <label for="speedUp" class="input-label"
                    >Speed Up (%)</label
                  >
                  <input
                    type="number"
                    id="speedUp"
                    value="75"
                    min="1"
                    max="110"
                    class="input-field"
                  />
                </div>
                <div class="input-grid-item">
                  <label for="speedDown" class="input-label"
                    >Speed Down (%)</label
                  >
                  <input
                    type="number"
                    id="speedDown"
                    value="25"
                    min="1"
                    max="110"
                    class="input-field"
                  />
                </div>
              </div>
            </div>

            <!-- Plot Buttons -->
            <div class="panel-section">
              <button
                class="btn btn-success mr2"
                id="plotBtn"
                onclick="plotFromEditorOrSvg()"
              >
                Plot
              </button>
              <button
                class="btn btn-primary mr2 hidden"
                id="resumeBtn"
                onclick="resumePlot()"
              >
                Resume
              </button>
              <button
                class="btn btn-primary hidden"
                id="returnHomeBtn"
                onclick="returnHome()"
              >
                Go to Home
              </button>
            </div>
          </div>
        </div>

        <!-- Right Column: Preview + SVG Text Area -->
        <div class="w-50 pl2">
          <!-- Preview Section -->
          <div class="flex items-center justify-between mb2">
            <h2 class="panel-title">Preview</h2>
            <div class="flex">
              <button
                @click="copySvg()"
                class="btn btn-icon mr2"
                title="Copy SVG"
              >
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
                  <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
                </svg>
              </button>
              <button
                onclick="exportSvg()"
                class="btn btn-icon"
                title="Export SVG"
              >
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M12 2v13"/>
                  <path d="m16 6-4-4-4 4"/>
                  <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/>
                </svg>
              </button>
            </div>
          </div>
          <div class="preview-container mb3" id="previewContainer">
            <div class="text-muted">
              Click the preview circle to see your sketch
            </div>
          </div>

          <!-- SVG Text Area -->
          <div>
            <label for="svgInput" class="input-label">SVG Text Area</label>
            <textarea
              id="svgInput"
              placeholder="Paste SVG content here..."
              class="input-field input-field-textarea"
            ></textarea>
          </div>
        </div>
      </div>

      <!-- Exported SVG Container (hidden by default) -->
      <div class="panel hidden" id="exportedSvgContainer">
        <label for="exportedSvg" class="input-label"
          >Exported SVG</label
        >
        <textarea
          id="exportedSvg"
          readonly
          class="input-field input-field-textarea"
        ></textarea>
      </div>
    </div>

    <!-- Interactive Mode Content -->
    <div x-show="currentMode === 'interactive'">
      <div class="flex">
        <!-- Command Reference (Left) -->
        <div class="w-50 pr2">
          <div class="panel">
            <h2 class="panel-title">Command Reference</h2>
            <div class="command-reference">
              <div class="command-item">
                <div class="command-name">moveto x y</div>
                <div class="command-description">Absolute pen-up move to (x, y)</div>
              </div>
              <div class="command-item">
                <div class="command-name">lineto x y</div>
                <div class="command-description">Absolute pen-down move to (x, y)</div>
              </div>
              <div class="command-item">
                <div class="command-name">penup</div>
                <div class="command-description">Raise pen</div>
              </div>
              <div class="command-item">
                <div class="command-name">pendown</div>
                <div class="command-description">Lower pen</div>
              </div>
              <div class="command-item">
                <div class="command-name">home</div>
                <div class="command-description">Move to home position (0, 0)</div>
              </div>
            </div>
          </div>
        </div>

        <!-- REPL (Right) -->
        <div class="w-50 pl2">
          <div class="panel">
            <h2 class="panel-title">REPL</h2>
            <div class="panel-section">
              <div class="repl-input-container">
                <input
                  type="text"
                  id="commandInput"
                  placeholder="e.g., moveto 1 1"
                  @keydown.enter="sendCommand()"
                  class="input-field repl-input"
                />
                <button
                  class="btn btn-primary"
                  id="sendBtn"
                  @click="sendCommand()"
                  :disabled="!connected"
                >
                  Send
                </button>
              </div>
              <div class="repl-container">
                <template x-for="entry in commandHistory" :key="entry.timestamp">
                  <div class="repl-entry">
                    <div class="repl-command">
                      <span class="repl-command-prompt">&gt;</span>
                      <span x-text="entry.command"></span>
                    </div>
                    <div class="repl-response" x-text="entry.response"></div>
                  </div>
                </template>
                <div x-show="commandHistory.length === 0" class="repl-history-empty">
                  No commands yet. Enter a command above.
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Log Side Panel -->
    <div
      x-show="logPanelOpen"
      x-transition:enter="transition ease-out duration-300"
      x-transition:enter-start="translate-x-full"
      x-transition:enter-end="translate-x-0"
      x-transition:leave="transition ease-in duration-300"
      x-transition:leave-start="translate-x-0"
      x-transition:leave-end="translate-x-full"
      class="log-panel"
    >
      <!-- Panel Header -->
      <div class="log-panel-header">
        <h2 class="log-panel-title">Log</h2>
        <button
          @click="toggleLogPanel()"
          class="log-panel-close"
          title="Close"
        >
          ✕
        </button>
      </div>

      <!-- Log Content Area -->
      <div
        id="logArea"
        class="log-panel-content"
      >
        <!-- Log entries will be inserted here -->
      </div>
    </div>

    <!-- Backdrop/Overlay -->
    <div
      x-show="logPanelOpen"
      @click="toggleLogPanel()"
      x-transition:enter="transition ease-out duration-300"
      x-transition:enter-start="opacity-0"
      x-transition:enter-end="opacity-100"
      x-transition:leave="transition ease-in duration-300"
      x-transition:leave-start="opacity-100"
      x-transition:leave-end="opacity-0"
      class="log-backdrop"
    ></div>

    <script>
      // Make functions globally accessible for AlpineJS
      window.connected = false;

      // Make log function globally accessible
      window.log = function (message, type = "info") {
        const logArea = document.getElementById("logArea");
        if (!logArea) return;
        const timestamp = new Date().toLocaleTimeString();
        const entry = document.createElement("div");
        entry.className = `log-entry ${type}`;
        entry.textContent = `[${timestamp}] ${message}`;
        logArea.appendChild(entry);
        logArea.scrollTop = logArea.scrollHeight;
      };

      // Alias for backward compatibility
      function log(message, type = "info") {
        window.log(message, type);
      }

      // Get AlpineJS component instance
      function getAlpineData() {
        return Alpine.$data(document.querySelector("[x-data]"));
      }

      function updateState(state) {
        const alpineData = getAlpineData();
        if (alpineData) {
          // Update AlpineJS reactive properties
          alpineData.connected = state.connected || false;
          alpineData.plotting = state.plotting || false;
          alpineData.paused = state.paused || false;
        }

        // Update global connected state for backward compatibility
        window.connected = state.connected;

        // Update plot button states (only if buttons exist - they're in Plot Mode)
        const plotBtn = document.getElementById("plotBtn");
        const resumeBtn = document.getElementById("resumeBtn");
        const returnHomeBtn = document.getElementById("returnHomeBtn");

        if (plotBtn && resumeBtn && returnHomeBtn) {
          const plotting = state.plotting || false;
          const paused = state.paused || false;

          // Plot button: enabled when not plotting and not paused
          if (!plotting && !paused) {
            plotBtn.disabled = false;
          } else {
            plotBtn.disabled = true;
          }

          // Resume button: visible only when paused
          if (paused) {
            resumeBtn.classList.remove("hidden");
          } else {
            resumeBtn.classList.add("hidden");
          }

          // Return Home button: visible only when paused (after physical pause button)
          if (paused) {
            returnHomeBtn.classList.remove("hidden");
          } else {
            returnHomeBtn.classList.add("hidden");
          }
        }

        if (state.error) {
          window.log(`State error: ${state.error}`, "error");
        }
      }

      // Make checkState globally accessible
      window.checkState = async function () {
        try {
          const response = await fetch("/state");
          const state = await response.json();
          updateState(state);
        } catch (error) {
          window.log(`Error checking state: ${error.message}`, "error");
        }
      };

      // Alias for backward compatibility
      async function checkState() {
        await window.checkState();
      }

      // Legacy functions for backward compatibility (now call AlpineJS methods)
      async function connect() {
        const alpineData = getAlpineData();
        if (alpineData && alpineData.connect) {
          await alpineData.connect();
        }
      }

      async function disconnect() {
        const alpineData = getAlpineData();
        if (alpineData && alpineData.disconnect) {
          await alpineData.disconnect();
        }
      }

      function handleKeyPress(event) {
        // Handled by AlpineJS @keydown.enter now
      }

      // Smart plot function: plots from SVG text area if it has content, otherwise from editor
      async function plotFromEditorOrSvg() {
        const svgInput = document.getElementById("svgInput");
        const svgText = svgInput ? svgInput.value.trim() : "";

        if (svgText) {
          // Plot from SVG text area
          await plot();
        } else {
          // Plot from editor
          await plotFromEditor();
        }
      }

      async function plot() {
        const svgInput = document.getElementById("svgInput");
        const svg = svgInput.value.trim();

        if (!svg) {
          log("Please paste SVG content", "error");
          return;
        }

        const layerInput = document.getElementById("layerInput");
        const penUp = parseInt(document.getElementById("penUp").value) || 70;
        const penDown =
          parseInt(document.getElementById("penDown").value) || 40;
        const speedUp =
          parseInt(document.getElementById("speedUp").value) || 75;
        const speedDown =
          parseInt(document.getElementById("speedDown").value) || 25;

        const payload = {
          svg: svg,
          settings: {
            pen_up: penUp,
            pen_down: penDown,
            speed_up: speedUp,
            speed_down: speedDown,
          },
        };

        const layer = layerInput.value.trim();
        if (layer) {
          payload.layer = parseInt(layer);
        }

        try {
          log("Starting plot...", "info");
          const response = await fetch("/plot", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          });
          const result = await response.json();

          if (result.success) {
            log(result.message || "Plot completed successfully", "success");
          } else {
            const errorMsg = result.error || "Plot failed";
            log(`Plot failed: ${errorMsg}`, "error");
            const alpineData = getAlpineData();
            if (alpineData) {
              alpineData.showAlert(`Plot Failed: ${errorMsg}`, "error");
            }
          }
        } catch (error) {
          const errorMsg = error.message || "Plot error";
          log(`Error plotting: ${errorMsg}`, "error");
          const alpineData = getAlpineData();
          if (alpineData) {
            alpineData.showAlert(`Plot Error: ${errorMsg}`, "error");
          }
        }
      }

      async function resumePlot() {
        try {
          log("Resuming plot...", "info");
          const response = await fetch("/resume", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
          });
          const result = await response.json();

          if (result.success) {
            log(result.message || "Plot resumed successfully", "success");
          } else {
            const errorMsg = result.error || "Resume failed";
            log(`Resume failed: ${errorMsg}`, "error");
            const alpineData = getAlpineData();
            if (alpineData) {
              alpineData.showAlert(`Resume Failed: ${errorMsg}`, "error");
            }
          }

          await checkState();
        } catch (error) {
          const errorMsg = error.message || "Resume error";
          log(`Error resuming plot: ${errorMsg}`, "error");
          const alpineData = getAlpineData();
          if (alpineData) {
            alpineData.showAlert(`Resume Error: ${errorMsg}`, "error");
          }
        }
      }

      async function returnHome() {
        try {
          log("Returning to home corner...", "info");
          const response = await fetch("/home", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
          });
          const result = await response.json();

          if (result.success) {
            log(result.message || "Returned to home successfully", "success");
          } else {
            log(`Return home failed: ${result.error}`, "error");
          }

          await checkState();
        } catch (error) {
          log(`Error returning home: ${error.message}`, "error");
        }
      }

      // Check state on page load
      checkState();

      // Poll state every 1 second (more frequent to catch pause state changes)
      setInterval(checkState, 1000);

      // Editor functionality
      let codeEditor;
      let previewIframe = null;
      let currentSvg = null;
      let defaultCode = `function setup() {
  createCanvas(780, 560); // 8.125" x 5.83" at 96 dpi
  background(255);
  noFill();
}

function draw() {
  square(50, 100, 40);
}`;

      // Shared SVG generation function
      async function generateSvgFromCode(code) {
        if (!code.trim()) {
          throw new Error("Please enter some code");
        }

        // Create a temporary iframe to generate SVG
        const tempIframe = document.createElement("iframe");
        tempIframe.style.display = "none";
        document.body.appendChild(tempIframe);

        const iframeWindow = tempIframe.contentWindow;
        const iframeDoc = tempIframe.contentDocument;

        // Wait for iframe to load
        await new Promise((resolve) => {
          tempIframe.onload = resolve;
          iframeDoc.open();
          iframeDoc.write(
            `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <` +
              `script src="/static/vendor/p5.js"></` +
              `script>
    <` +
              `script src="/static/vendor/p5.plotSvg.js"></` +
              `script>
</head>
<body>
    <` +
              `script>
        p5.disableFriendlyErrors = true;
        let svgResult = null;
        
        // User code defines setup() and draw() globally
        ${code}
        
        // Wait for p5 to initialize, then capture SVG
        function captureSvg() {
            if (typeof setup === 'function' || typeof draw === 'function') {
                // Run setup first to create canvas
                if (typeof setup === 'function') {
                    setup();
                }
                
                // Get canvas dimensions after setup runs
                let canvasWidth = 780; // default fallback
                let canvasHeight = 560; // default fallback
                
                // Try multiple methods to get canvas dimensions
                if (typeof width !== 'undefined' && typeof height !== 'undefined') {
                    canvasWidth = width;
                    canvasHeight = height;
                } else {
                    // Try to find the canvas element
                    const canvas = document.querySelector('canvas');
                    if (canvas) {
                        canvasWidth = canvas.width;
                        canvasHeight = canvas.height;
                    }
                }
                
                // Set SVG document size to match canvas exactly (ensures coordinate mapping)
                setSvgDocumentSize(canvasWidth, canvasHeight);
                // Set resolution to 96 DPI (matches p5.plotSvg default and pyaxidraw inches)
                setSvgResolutionDPI(96);
                
                // Use window as the instance (works in global mode)
                beginRecordSvg(window, null);
                // Re-run setup and draw to capture SVG
                if (typeof setup === 'function') setup();
                if (typeof draw === 'function') draw();
                svgResult = endRecordSvg();
                window.parent.postMessage({type: 'svgResult', svg: svgResult}, '*');
            } else {
                window.parent.postMessage({type: 'svgError', error: 'No setup() or draw() function found'}, '*');
            }
        }
        
        // Wait a bit for p5.js library to load and initialize
        setTimeout(captureSvg, 300);
    </` +
              `script>
</body>
</html>`
          );
          iframeDoc.close();
        });

        // Wait for SVG result via postMessage
        const svgString = await new Promise((resolve, reject) => {
          const messageHandler = (event) => {
            if (event.data.type === "svgResult") {
              window.removeEventListener("message", messageHandler);
              document.body.removeChild(tempIframe);
              resolve(event.data.svg);
            } else if (event.data.type === "svgError") {
              window.removeEventListener("message", messageHandler);
              document.body.removeChild(tempIframe);
              reject(new Error(event.data.error));
            }
          };
          window.addEventListener("message", messageHandler);

          // Timeout after 5 seconds
          setTimeout(() => {
            window.removeEventListener("message", messageHandler);
            if (document.body.contains(tempIframe)) {
              document.body.removeChild(tempIframe);
            }
            reject(new Error("SVG generation timeout"));
          }, 5000);
        });

        if (!svgString) {
          throw new Error("Failed to generate SVG");
        }

        return svgString;
      }

      // Initialize CodeMirror when page loads
      window.addEventListener("DOMContentLoaded", function () {
        // Load CodeMirror script dynamically
        const codemirrorScript = document.createElement("script");
        codemirrorScript.src = "/static/vendor/codemirror/codemirror.js";
        codemirrorScript.onload = function () {
          const jsModeScript = document.createElement("script");
          jsModeScript.src =
            "/static/vendor/codemirror/mode/javascript/javascript.js";
          jsModeScript.onload = function () {
            const textarea = document.getElementById("codeEditor");
            // Ensure textarea has the value before CodeMirror reads it
            if (textarea.value !== defaultCode) {
              textarea.value = defaultCode;
            }
            codeEditor = CodeMirror.fromTextArea(textarea, {
              lineNumbers: true,
              mode: "javascript",
              theme: "isotope",
              indentUnit: 2,
              lineWrapping: true,
            });
            // Set value immediately after creation
            setTimeout(() => {
              codeEditor.setValue(defaultCode);
            }, 0);
          };
          document.head.appendChild(jsModeScript);
        };
        document.head.appendChild(codemirrorScript);
      });

      function runPreview() {
        const code = codeEditor
          ? codeEditor.getValue()
          : document.getElementById("codeEditor").value;

        if (!code.trim()) {
          log("Please enter some code", "error");
          return;
        }

        // Create or update preview iframe
        const previewContainer = document.getElementById("previewContainer");

        // Remove placeholder message if it exists
        const placeholder = previewContainer.querySelector("div.flex");
        if (
          placeholder &&
          placeholder.textContent.includes('Click "Run Preview"')
        ) {
          previewContainer.removeChild(placeholder);
        }

        // Remove existing iframe if it exists
        if (previewIframe) {
          previewContainer.removeChild(previewIframe);
        }

        previewIframe = document.createElement("iframe");
        previewIframe.id = "previewFrame";
        previewIframe.className = "w-100 h-100 bn";
        previewContainer.appendChild(previewIframe);

        // Create HTML content for iframe
        const iframeDoc =
          previewIframe.contentDocument || previewIframe.contentWindow.document;
        const htmlContent =
          `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <` +
          `script src="/static/vendor/p5.js"></` +
          `script>
    <` +
          `script src="/static/vendor/p5.plotSvg.js"></` +
          `script>
    <style>
        body { margin: 0; padding: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <` +
          `script>
        p5.disableFriendlyErrors = true;
        ${code}
    </` +
          `script>
</body>
</html>`;

        iframeDoc.open();
        iframeDoc.write(htmlContent);
        iframeDoc.close();

        log("Preview updated", "success");
      }

      async function plotFromEditor() {
        const code = codeEditor
          ? codeEditor.getValue()
          : document.getElementById("codeEditor").value;

        try {
          log("Generating SVG...", "info");

          // Generate SVG using shared function
          const svgString = await generateSvgFromCode(code);

          currentSvg = svgString;
          // Update AlpineJS state
          const alpineData = getAlpineData();
          if (alpineData) {
            alpineData.currentSvg = svgString;
          }

          // Send to backend for plotting
          const layerInput = document.getElementById("layerInput");
          const penUp = parseInt(document.getElementById("penUp").value) || 70;
          const penDown =
            parseInt(document.getElementById("penDown").value) || 40;
          const speedUp =
            parseInt(document.getElementById("speedUp").value) || 75;
          const speedDown =
            parseInt(document.getElementById("speedDown").value) || 25;

          const payload = {
            svg: svgString,
            settings: {
              pen_up: penUp,
              pen_down: penDown,
              speed_up: speedUp,
              speed_down: speedDown,
            },
          };

          const layer = layerInput.value.trim();
          if (layer) {
            payload.layer = parseInt(layer);
          }

          log("Sending SVG to plotter...", "info");
          const response = await fetch("/plot", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          });
          const result = await response.json();

          if (result.success) {
            log(result.message || "Plot started successfully", "success");
          } else {
            const errorMsg = result.error || "Plot failed";
            log(`Plot failed: ${errorMsg}`, "error");
            const alpineData = getAlpineData();
            if (alpineData) {
              alpineData.showAlert(`Plot Failed: ${errorMsg}`, "error");
            }
          }
        } catch (error) {
          const errorMsg = error.message || "Plot error";
          log(`Error plotting: ${errorMsg}`, "error");
          console.error(error);
          const alpineData = getAlpineData();
          if (alpineData) {
            alpineData.showAlert(`Plot Error: ${errorMsg}`, "error");
          }
        }
      }

      async function exportSvg() {
        const code = codeEditor
          ? codeEditor.getValue()
          : document.getElementById("codeEditor").value;

        try {
          log("Generating SVG...", "info");

          // Generate SVG using shared function
          const svgString = await generateSvgFromCode(code);

          currentSvg = svgString;
          // Update AlpineJS state
          const alpineData = getAlpineData();
          if (alpineData) {
            alpineData.currentSvg = svgString;
          }

          // Download SVG directly
          const blob = new Blob([svgString], { type: "image/svg+xml" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "sketch.svg";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          log("SVG exported and downloaded successfully", "success");
        } catch (error) {
          log(`Error exporting SVG: ${error.message}`, "error");
          console.error(error);
        }
      }

      function downloadSvg() {
        if (!currentSvg) {
          log("No SVG to download. Please export SVG first.", "error");
          return;
        }

        const blob = new Blob([currentSvg], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "sketch.svg";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        log("SVG downloaded", "success");
      }
    </script>
    </div>
  </body>
</html>
