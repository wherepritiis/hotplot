<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AxiDraw Control Panel</title>
    <!-- Tachyons CSS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/tachyons@4.12.0/css/tachyons.min.css"
    />
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="/static/vendor/codemirror/codemirror.css" />
    <!-- AlpineJS Data Component - Define before Alpine loads -->
    <script>
      // Define Alpine component data function
      const appDataDefinition = () => ({
        currentMode: "plot",
        logPanelOpen: false,
        connected: false,
        plotting: false,
        paused: false,
        commandHistory: [],
        currentSvg: null,
        alerts: [],

        switchMode(mode) {
          this.currentMode = mode;
        },
        toggleLogPanel() {
          this.logPanelOpen = !this.logPanelOpen;
        },
        showAlert(message, type = "error") {
          const alert = {
            id: Date.now() + Math.random(),
            message: message,
            type: type, // "error", "success", "info", "warning"
          };
          this.alerts.push(alert);
          
          // Auto-dismiss after 5 seconds for errors, 3 seconds for others
          const dismissTime = type === "error" ? 5000 : 3000;
          setTimeout(() => {
            this.dismissAlert(alert.id);
          }, dismissTime);
        },
        dismissAlert(id) {
          this.alerts = this.alerts.filter(alert => alert.id !== id);
        },
        async connect() {
          try {
            window.log("Connecting...", "info");
            const response = await fetch("/connect", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
            });
            const result = await response.json();
            if (result.success) {
              window.log(result.message || "Connected successfully", "success");
              this.connected = true;
            } else {
              const errorMsg = result.error || "Connection failed";
              window.log(`Connection failed: ${errorMsg}`, "error");
              this.showAlert(`Connection Failed: ${errorMsg}`, "error");
              this.connected = false;
            }
            await window.checkState();
          } catch (error) {
            const errorMsg = error.message || "Connection error";
            window.log(`Error connecting: ${errorMsg}`, "error");
            this.showAlert(`Connection Error: ${errorMsg}`, "error");
            this.connected = false;
          }
        },
        async disconnect() {
          try {
            window.log("Disconnecting...", "info");
            const response = await fetch("/disconnect", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
            });
            const result = await response.json();
            if (result.success) {
              window.log(
                result.message || "Disconnected successfully",
                "success"
              );
              this.connected = false;
            } else {
              const errorMsg = result.error || "Disconnect failed";
              window.log(`Disconnect failed: ${errorMsg}`, "error");
              this.showAlert(`Disconnect Failed: ${errorMsg}`, "error");
            }
            await window.checkState();
          } catch (error) {
            const errorMsg = error.message || "Disconnect error";
            window.log(`Error disconnecting: ${errorMsg}`, "error");
            this.showAlert(`Disconnect Error: ${errorMsg}`, "error");
          }
        },
        async sendCommand() {
          const commandInput = document.getElementById("commandInput");
          const command = commandInput.value.trim();
          if (!command) {
            window.log("Please enter a command", "error");
            return;
          }
          if (!this.connected) {
            window.log("Not connected. Please connect first.", "error");
            return;
          }
          try {
            window.log(`Sending command: ${command}`, "info");
            const response = await fetch("/cmd", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ command: command }),
            });
            const result = await response.json();
            if (result.success) {
              window.log(
                result.message || "Command executed successfully",
                "success"
              );
              this.addToHistory(command, result.message || "Success");
            } else {
              const errorMsg = result.error || "Command failed";
              window.log(`Command failed: ${errorMsg}`, "error");
              this.showAlert(`Command Failed: ${errorMsg}`, "error");
              this.addToHistory(command, `Error: ${errorMsg}`);
            }
            commandInput.value = "";
          } catch (error) {
            const errorMsg = error.message || "Command error";
            window.log(`Error sending command: ${errorMsg}`, "error");
            this.showAlert(`Command Error: ${errorMsg}`, "error");
            this.addToHistory(command, `Error: ${errorMsg}`);
          }
        },
        addToHistory(command, response) {
          this.commandHistory.push({
            command,
            response,
            timestamp: new Date(),
          });
        },
        async copySvg() {
          try {
            let svgToCopy =
              this.currentSvg ||
              (typeof currentSvg !== "undefined" ? currentSvg : null);
            
            // If no SVG is available, generate it from the code editor
            if (!svgToCopy) {
              window.log("Generating SVG from code...", "info");
              
              // Get code from editor
              const code = codeEditor
                ? codeEditor.getValue()
                : document.getElementById("codeEditor").value;
              
              // Generate SVG
              svgToCopy = await generateSvgFromCode(code);
              
              // Store the generated SVG
              currentSvg = svgToCopy;
              this.currentSvg = svgToCopy;
            }
            
            // Copy to clipboard
            await navigator.clipboard.writeText(svgToCopy);
            window.log("SVG copied to clipboard", "success");
          } catch (error) {
            window.log(`Error copying SVG: ${error.message}`, "error");
          }
        },
      });
    </script>
    <!-- AlpineJS - Load without defer to ensure proper initialization order -->
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <!-- Register Alpine data immediately after Alpine loads -->
    <script>
      // Register Alpine data component - Alpine is now loaded
      Alpine.data("appData", appDataDefinition);
    </script>
    <!-- p5.js and p5.plotSvg will be loaded dynamically in preview iframe -->
  </head>
  <body
    x-data="appData"
    class="sans-serif w-100 center pa3 bg-light-gray"
    style="max-width: 1920px"
  >
    <!-- Alert Notifications -->
    <div
      class="fixed top-0 left-0 right-0 pa3"
      style="z-index: 10000; pointer-events: none;"
    >
      <div class="center" style="max-width: 1920px;">
        <template x-for="alert in alerts" :key="alert.id">
          <div
            x-show="alerts.length > 0"
            x-transition:enter="transition ease-out duration-300"
            x-transition:enter-start="opacity-0 transform translate-y-[-10px]"
            x-transition:enter-end="opacity-100 transform translate-y-0"
            x-transition:leave="transition ease-in duration-200"
            x-transition:leave-start="opacity-100 transform translate-y-0"
            x-transition:leave-end="opacity-0 transform translate-y-[-10px]"
            :class="{
              'bg-red white': alert.type === 'error',
              'bg-green white': alert.type === 'success',
              'bg-blue white': alert.type === 'info',
              'bg-yellow black': alert.type === 'warning'
            }"
            class="br3 pa3 mb2 shadow-4 flex items-center justify-between"
            style="pointer-events: auto; min-width: 300px; max-width: 600px;"
          >
            <span x-text="alert.message" class="flex-auto pr2"></span>
            <button
              @click="dismissAlert(alert.id)"
              :class="alert.type === 'warning' ? 'bg-transparent black' : 'bg-transparent white'"
              class="bn pointer f4"
              style="line-height: 1;"
              title="Dismiss"
            >
              ×
            </button>
          </div>
        </template>
      </div>
    </div>

    <!-- Header -->
    <header
      class="bg-white br3 pa3 mb3 shadow-2 flex items-center justify-between"
    >
      <!-- Mode Tabs (Left) -->
      <div class="flex">
        <button
          @click="switchMode('plot')"
          :class="currentMode === 'plot' ? 'bg-black white' : 'bg-white black'"
          class="pa2 br2 bn pointer mr2"
        >
          Plot Mode
        </button>
        <button
          @click="switchMode('interactive')"
          :class="currentMode === 'interactive' ? 'bg-black white' : 'bg-white black'"
          class="pa2 br2 bn pointer ba"
        >
          Interactive Mode
        </button>
      </div>

      <!-- Connection Controls (Right) -->
      <div class="flex items-center">
        <span class="mr2 f6">Connect</span>
        <label class="pointer">
          <input
            type="checkbox"
            :checked="connected"
            @change="connected ? disconnect() : connect()"
            class="mr2"
          />
        </label>
        <span class="mr2 f6">Status</span>
        <div
          :class="connected ? 'bg-green' : 'bg-red'"
          class="w2 h2 br-100 mr3"
          id="statusIndicator"
        ></div>
        <span class="mr3">|</span>
        <button
          @click="toggleLogPanel()"
          class="bg-white black pa2 br2 bn pointer ba"
        >
          Log
        </button>
      </div>
    </header>

    <!-- Plot Mode Content -->
    <div x-show="currentMode === 'plot'">
      <div class="flex">
        <!-- Left Column: Editor + Plot Settings + Buttons -->
        <div class="w-50 pr2">
          <div class="bg-white br3 pa4 mb3 shadow-2">
            <h2 class="f3 fw5 black mb3">Editor</h2>
            <div class="mb3">
              <textarea
                id="codeEditor"
                class="w-100 pa2 ba br2"
                style="min-height: 400px"
              ></textarea>
            </div>
            <div class="mb3">
              <button
                class="bg-blue white pa2 br2 bn pointer"
                id="runPreviewBtn"
                onclick="runPreview()"
              >
                Run Preview
              </button>
            </div>

            <div class="mb3">
              <label for="layerInput" class="f6 fw5 black mb2 db"
                >Layer Number (optional)</label
              >
              <input
                type="number"
                id="layerInput"
                placeholder="Leave empty for all layers"
                class="w-100 pa2 ba br2"
              />
            </div>

            <!-- Plot Settings Grid (2x2) -->
            <div class="flex mb2">
              <div class="w-50 pr1">
                <label for="penUp" class="f6 fw5 black mb2 db"
                  >Pen Up Height</label
                >
                <input
                  type="number"
                  id="penUp"
                  value="70"
                  min="0"
                  max="100"
                  class="w-100 pa2 ba br2"
                />
              </div>
              <div class="w-50 pl1">
                <label for="penDown" class="f6 fw5 black mb2 db"
                  >Pen Down Height</label
                >
                <input
                  type="number"
                  id="penDown"
                  value="40"
                  min="0"
                  max="100"
                  class="w-100 pa2 ba br2"
                />
              </div>
            </div>

            <div class="flex mb3">
              <div class="w-50 pr1">
                <label for="speedUp" class="f6 fw5 black mb2 db"
                  >Speed Up (%)</label
                >
                <input
                  type="number"
                  id="speedUp"
                  value="75"
                  min="1"
                  max="110"
                  class="w-100 pa2 ba br2"
                />
              </div>
              <div class="w-50 pl1">
                <label for="speedDown" class="f6 fw5 black mb2 db"
                  >Speed Down (%)</label
                >
                <input
                  type="number"
                  id="speedDown"
                  value="25"
                  min="1"
                  max="110"
                  class="w-100 pa2 ba br2"
                />
              </div>
            </div>

            <!-- Plot Buttons -->
            <div class="flex">
              <button
                class="bg-green white pa2 br2 bn pointer mr2"
                id="plotBtn"
                onclick="plotFromEditorOrSvg()"
              >
                Plot
              </button>
              <button
                class="bg-blue white pa2 br2 bn pointer dn mr2"
                id="resumeBtn"
                onclick="resumePlot()"
              >
                Resume
              </button>
              <button
                class="bg-purple white pa2 br2 bn pointer dn"
                id="returnHomeBtn"
                onclick="returnHome()"
              >
                Go to Home
              </button>
            </div>
          </div>
        </div>

        <!-- Right Column: Preview + SVG Text Area -->
        <div class="w-50 pl2">
          <div class="bg-white br3 pa4 mb3 shadow-2">
            <!-- Preview Section -->
            <div class="flex items-center justify-between mb2">
              <h2 class="f3 fw5 black">Preview</h2>
              <div class="flex">
                <button
                  @click="copySvg()"
                  class="bg-white black pa2 br2 bn pointer ba mr2"
                  title="Copy SVG"
                >
                  Copy
                </button>
                <button
                  onclick="exportSvg()"
                  class="bg-white black pa2 br2 bn pointer ba"
                  title="Export SVG"
                >
                  Export
                </button>
              </div>
            </div>
            <div
              class="w-100 ba br2 bg-near-white overflow-hidden mb3"
              id="previewContainer"
              style="height: 400px"
            >
              <div class="flex items-center justify-center h-100 gray">
                Click "Run Preview" to see your sketch
              </div>
            </div>

            <!-- SVG Text Area -->
            <div>
              <label for="svgInput" class="f6 fw5 black mb2 db"
                >SVG Text Area</label
              >
              <textarea
                id="svgInput"
                placeholder="Paste SVG content here..."
                class="w-100 pa2 ba br2"
                style="min-height: 200px"
              ></textarea>
            </div>
          </div>
        </div>
      </div>

      <!-- Exported SVG Container (hidden by default) -->
      <div class="bg-white br3 pa4 mb3 shadow-2 dn" id="exportedSvgContainer">
        <label for="exportedSvg" class="f6 fw5 black mb2 db"
          >Exported SVG</label
        >
        <textarea
          id="exportedSvg"
          readonly
          class="w-100 pa2 ba br2"
          style="min-height: 200px"
        ></textarea>
      </div>
    </div>

    <!-- Interactive Mode Content -->
    <div x-show="currentMode === 'interactive'">
      <div class="flex">
        <!-- Command Reference (Left) -->
        <div class="w-50 pr2">
          <div class="bg-white br3 pa4 mb3 shadow-2">
            <h2 class="f3 fw5 black mb3">Command Reference</h2>
            <div class="overflow-auto" style="max-height: 600px">
              <div class="mb3">
                <div class="f6 fw6 black mb1">moveto x y</div>
                <div class="f6 gray">Absolute pen-up move to (x, y)</div>
              </div>
              <div class="mb3">
                <div class="f6 fw6 black mb1">lineto x y</div>
                <div class="f6 gray">Absolute pen-down move to (x, y)</div>
              </div>
              <div class="mb3">
                <div class="f6 fw6 black mb1">penup</div>
                <div class="f6 gray">Raise pen</div>
              </div>
              <div class="mb3">
                <div class="f6 fw6 black mb1">pendown</div>
                <div class="f6 gray">Lower pen</div>
              </div>
              <div class="mb3">
                <div class="f6 fw6 black mb1">home</div>
                <div class="f6 gray">Move to home position (0, 0)</div>
              </div>
            </div>
          </div>
        </div>

        <!-- REPL (Right) -->
        <div class="w-50 pl2">
          <div class="bg-white br3 pa4 mb3 shadow-2">
            <h2 class="f3 fw5 black mb3">REPL</h2>
            <div class="flex mb3">
              <input
                type="text"
                id="commandInput"
                placeholder="e.g., moveto 1 1"
                @keydown.enter="sendCommand()"
                class="flex-auto pa2 ba br2 mr2"
              />
              <button
                class="bg-blue white pa2 br2 bn pointer"
                id="sendBtn"
                @click="sendCommand()"
                :disabled="!connected"
              >
                Send
              </button>
            </div>
            <div
              class="bg-near-white ba br2 pa3 overflow-auto"
              style="min-height: 400px; max-height: 500px"
            >
              <template x-for="entry in commandHistory" :key="entry.timestamp">
                <div class="mb2">
                  <div class="f6 black mb1">
                    <span class="fw6">&gt; </span
                    ><span x-text="entry.command"></span>
                  </div>
                  <div class="f6 gray ml3" x-text="entry.response"></div>
                </div>
              </template>
              <div x-show="commandHistory.length === 0" class="gray f6">
                No commands yet. Enter a command above.
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Log Side Panel -->
    <div
      x-show="logPanelOpen"
      x-transition:enter="transition ease-out duration-300"
      x-transition:enter-start="translate-x-full"
      x-transition:enter-end="translate-x-0"
      x-transition:leave="transition ease-in duration-300"
      x-transition:leave-start="translate-x-0"
      x-transition:leave-end="translate-x-full"
      class="fixed top-0 right-0 h-100 w5 bg-white shadow-4 flex flex-column"
      style="max-width: 400px; z-index: 9999"
    >
      <!-- Panel Header -->
      <div class="flex items-center justify-between pa3 bb b--gray">
        <h2 class="f3 fw5 black ma0">Log</h2>
        <button
          @click="toggleLogPanel()"
          class="bg-white black pa2 br2 bn pointer ba"
          title="Close"
        >
          ✕
        </button>
      </div>

      <!-- Log Content Area -->
      <div
        id="logArea"
        class="flex-auto pa3 overflow-auto bg-near-white"
        style="min-height: 0"
      >
        <!-- Log entries will be inserted here -->
      </div>
    </div>

    <!-- Backdrop/Overlay -->
    <div
      x-show="logPanelOpen"
      @click="toggleLogPanel()"
      x-transition:enter="transition ease-out duration-300"
      x-transition:enter-start="opacity-0"
      x-transition:enter-end="opacity-100"
      x-transition:leave="transition ease-in duration-300"
      x-transition:leave-start="opacity-100"
      x-transition:leave-end="opacity-0"
      class="fixed top-0 left-0 right-0 bottom-0 bg-black"
      style="opacity: 0.5; z-index: 9998"
    ></div>

    <script>
      // Make functions globally accessible for AlpineJS
      window.connected = false;

      // Make log function globally accessible
      window.log = function (message, type = "info") {
        const logArea = document.getElementById("logArea");
        if (!logArea) return;
        const timestamp = new Date().toLocaleTimeString();
        const entry = document.createElement("div");
        entry.className = "mb2";
        // Apply Tachyons color classes based on type
        if (type === "success") {
          entry.className += " green";
        } else if (type === "error") {
          entry.className += " red";
        } else {
          entry.className += " blue";
        }
        entry.textContent = `[${timestamp}] ${message}`;
        logArea.appendChild(entry);
        logArea.scrollTop = logArea.scrollHeight;
      };

      // Alias for backward compatibility
      function log(message, type = "info") {
        window.log(message, type);
      }

      // Get AlpineJS component instance
      function getAlpineData() {
        return Alpine.$data(document.querySelector("[x-data]"));
      }

      function updateState(state) {
        const alpineData = getAlpineData();
        if (alpineData) {
          // Update AlpineJS reactive properties
          alpineData.connected = state.connected || false;
          alpineData.plotting = state.plotting || false;
          alpineData.paused = state.paused || false;
        }

        // Update global connected state for backward compatibility
        window.connected = state.connected;

        // Update plot button states (only if buttons exist - they're in Plot Mode)
        const plotBtn = document.getElementById("plotBtn");
        const resumeBtn = document.getElementById("resumeBtn");
        const returnHomeBtn = document.getElementById("returnHomeBtn");

        if (plotBtn && resumeBtn && returnHomeBtn) {
          const plotting = state.plotting || false;
          const paused = state.paused || false;

          // Plot button: enabled when not plotting and not paused
          if (!plotting && !paused) {
            plotBtn.disabled = false;
          } else {
            plotBtn.disabled = true;
          }

          // Resume button: visible only when paused
          if (paused) {
            resumeBtn.classList.remove("dn");
          } else {
            resumeBtn.classList.add("dn");
          }

          // Return Home button: visible only when paused (after physical pause button)
          if (paused) {
            returnHomeBtn.classList.remove("dn");
          } else {
            returnHomeBtn.classList.add("dn");
          }
        }

        if (state.error) {
          window.log(`State error: ${state.error}`, "error");
        }
      }

      // Make checkState globally accessible
      window.checkState = async function () {
        try {
          const response = await fetch("/state");
          const state = await response.json();
          updateState(state);
        } catch (error) {
          window.log(`Error checking state: ${error.message}`, "error");
        }
      };

      // Alias for backward compatibility
      async function checkState() {
        await window.checkState();
      }

      // Legacy functions for backward compatibility (now call AlpineJS methods)
      async function connect() {
        const alpineData = getAlpineData();
        if (alpineData && alpineData.connect) {
          await alpineData.connect();
        }
      }

      async function disconnect() {
        const alpineData = getAlpineData();
        if (alpineData && alpineData.disconnect) {
          await alpineData.disconnect();
        }
      }

      function handleKeyPress(event) {
        // Handled by AlpineJS @keydown.enter now
      }

      // Smart plot function: plots from SVG text area if it has content, otherwise from editor
      async function plotFromEditorOrSvg() {
        const svgInput = document.getElementById("svgInput");
        const svgText = svgInput ? svgInput.value.trim() : "";

        if (svgText) {
          // Plot from SVG text area
          await plot();
        } else {
          // Plot from editor
          await plotFromEditor();
        }
      }

      async function plot() {
        const svgInput = document.getElementById("svgInput");
        const svg = svgInput.value.trim();

        if (!svg) {
          log("Please paste SVG content", "error");
          return;
        }

        const layerInput = document.getElementById("layerInput");
        const penUp = parseInt(document.getElementById("penUp").value) || 70;
        const penDown =
          parseInt(document.getElementById("penDown").value) || 40;
        const speedUp =
          parseInt(document.getElementById("speedUp").value) || 75;
        const speedDown =
          parseInt(document.getElementById("speedDown").value) || 25;

        const payload = {
          svg: svg,
          settings: {
            pen_up: penUp,
            pen_down: penDown,
            speed_up: speedUp,
            speed_down: speedDown,
          },
        };

        const layer = layerInput.value.trim();
        if (layer) {
          payload.layer = parseInt(layer);
        }

        try {
          log("Starting plot...", "info");
          const response = await fetch("/plot", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          });
          const result = await response.json();

          if (result.success) {
            log(result.message || "Plot completed successfully", "success");
          } else {
            const errorMsg = result.error || "Plot failed";
            log(`Plot failed: ${errorMsg}`, "error");
            const alpineData = getAlpineData();
            if (alpineData) {
              alpineData.showAlert(`Plot Failed: ${errorMsg}`, "error");
            }
          }
        } catch (error) {
          const errorMsg = error.message || "Plot error";
          log(`Error plotting: ${errorMsg}`, "error");
          const alpineData = getAlpineData();
          if (alpineData) {
            alpineData.showAlert(`Plot Error: ${errorMsg}`, "error");
          }
        }
      }

      async function resumePlot() {
        try {
          log("Resuming plot...", "info");
          const response = await fetch("/resume", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
          });
          const result = await response.json();

          if (result.success) {
            log(result.message || "Plot resumed successfully", "success");
          } else {
            const errorMsg = result.error || "Resume failed";
            log(`Resume failed: ${errorMsg}`, "error");
            const alpineData = getAlpineData();
            if (alpineData) {
              alpineData.showAlert(`Resume Failed: ${errorMsg}`, "error");
            }
          }

          await checkState();
        } catch (error) {
          const errorMsg = error.message || "Resume error";
          log(`Error resuming plot: ${errorMsg}`, "error");
          const alpineData = getAlpineData();
          if (alpineData) {
            alpineData.showAlert(`Resume Error: ${errorMsg}`, "error");
          }
        }
      }

      async function returnHome() {
        try {
          log("Returning to home corner...", "info");
          const response = await fetch("/home", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
          });
          const result = await response.json();

          if (result.success) {
            log(result.message || "Returned to home successfully", "success");
          } else {
            log(`Return home failed: ${result.error}`, "error");
          }

          await checkState();
        } catch (error) {
          log(`Error returning home: ${error.message}`, "error");
        }
      }

      // Check state on page load
      checkState();

      // Poll state every 1 second (more frequent to catch pause state changes)
      setInterval(checkState, 1000);

      // Editor functionality
      let codeEditor;
      let previewIframe = null;
      let currentSvg = null;
      let defaultCode = `function setup() {
  createCanvas(780, 560); // 8.125" x 5.83" at 96 dpi
  background(255);
  noFill();
}

function draw() {
  square(50, 100, 40);
}`;

      // Shared SVG generation function
      async function generateSvgFromCode(code) {
        if (!code.trim()) {
          throw new Error("Please enter some code");
        }

        // Create a temporary iframe to generate SVG
        const tempIframe = document.createElement("iframe");
        tempIframe.style.display = "none";
        document.body.appendChild(tempIframe);

        const iframeWindow = tempIframe.contentWindow;
        const iframeDoc = tempIframe.contentDocument;

        // Wait for iframe to load
        await new Promise((resolve) => {
          tempIframe.onload = resolve;
          iframeDoc.open();
          iframeDoc.write(
            `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <` +
              `script src="/static/vendor/p5.js"></` +
              `script>
    <` +
              `script src="/static/vendor/p5.plotSvg.js"></` +
              `script>
</head>
<body>
    <` +
              `script>
        p5.disableFriendlyErrors = true;
        let svgResult = null;
        
        // User code defines setup() and draw() globally
        ${code}
        
        // Wait for p5 to initialize, then capture SVG
        function captureSvg() {
            if (typeof setup === 'function' || typeof draw === 'function') {
                // Run setup first to create canvas
                if (typeof setup === 'function') {
                    setup();
                }
                
                // Get canvas dimensions after setup runs
                let canvasWidth = 780; // default fallback
                let canvasHeight = 560; // default fallback
                
                // Try multiple methods to get canvas dimensions
                if (typeof width !== 'undefined' && typeof height !== 'undefined') {
                    canvasWidth = width;
                    canvasHeight = height;
                } else {
                    // Try to find the canvas element
                    const canvas = document.querySelector('canvas');
                    if (canvas) {
                        canvasWidth = canvas.width;
                        canvasHeight = canvas.height;
                    }
                }
                
                // Set SVG document size to match canvas exactly (ensures coordinate mapping)
                setSvgDocumentSize(canvasWidth, canvasHeight);
                // Set resolution to 96 DPI (matches p5.plotSvg default and pyaxidraw inches)
                setSvgResolutionDPI(96);
                
                // Use window as the instance (works in global mode)
                beginRecordSvg(window, null);
                // Re-run setup and draw to capture SVG
                if (typeof setup === 'function') setup();
                if (typeof draw === 'function') draw();
                svgResult = endRecordSvg();
                window.parent.postMessage({type: 'svgResult', svg: svgResult}, '*');
            } else {
                window.parent.postMessage({type: 'svgError', error: 'No setup() or draw() function found'}, '*');
            }
        }
        
        // Wait a bit for p5.js library to load and initialize
        setTimeout(captureSvg, 300);
    </` +
              `script>
</body>
</html>`
          );
          iframeDoc.close();
        });

        // Wait for SVG result via postMessage
        const svgString = await new Promise((resolve, reject) => {
          const messageHandler = (event) => {
            if (event.data.type === "svgResult") {
              window.removeEventListener("message", messageHandler);
              document.body.removeChild(tempIframe);
              resolve(event.data.svg);
            } else if (event.data.type === "svgError") {
              window.removeEventListener("message", messageHandler);
              document.body.removeChild(tempIframe);
              reject(new Error(event.data.error));
            }
          };
          window.addEventListener("message", messageHandler);

          // Timeout after 5 seconds
          setTimeout(() => {
            window.removeEventListener("message", messageHandler);
            if (document.body.contains(tempIframe)) {
              document.body.removeChild(tempIframe);
            }
            reject(new Error("SVG generation timeout"));
          }, 5000);
        });

        if (!svgString) {
          throw new Error("Failed to generate SVG");
        }

        return svgString;
      }

      // Initialize CodeMirror when page loads
      window.addEventListener("DOMContentLoaded", function () {
        // Load CodeMirror script dynamically
        const codemirrorScript = document.createElement("script");
        codemirrorScript.src = "/static/vendor/codemirror/codemirror.js";
        codemirrorScript.onload = function () {
          const jsModeScript = document.createElement("script");
          jsModeScript.src =
            "/static/vendor/codemirror/mode/javascript/javascript.js";
          jsModeScript.onload = function () {
            codeEditor = CodeMirror.fromTextArea(
              document.getElementById("codeEditor"),
              {
                lineNumbers: true,
                mode: "javascript",
                theme: "default",
                indentUnit: 2,
                lineWrapping: true,
              }
            );
            codeEditor.setValue(defaultCode);
            // Apply Tachyons border styling to CodeMirror
            codeEditor.getWrapperElement().classList.add("ba", "br2");
          };
          document.head.appendChild(jsModeScript);
        };
        document.head.appendChild(codemirrorScript);
      });

      function runPreview() {
        const code = codeEditor
          ? codeEditor.getValue()
          : document.getElementById("codeEditor").value;

        if (!code.trim()) {
          log("Please enter some code", "error");
          return;
        }

        // Create or update preview iframe
        const previewContainer = document.getElementById("previewContainer");

        // Remove placeholder message if it exists
        const placeholder = previewContainer.querySelector("div.flex");
        if (
          placeholder &&
          placeholder.textContent.includes('Click "Run Preview"')
        ) {
          previewContainer.removeChild(placeholder);
        }

        // Remove existing iframe if it exists
        if (previewIframe) {
          previewContainer.removeChild(previewIframe);
        }

        previewIframe = document.createElement("iframe");
        previewIframe.id = "previewFrame";
        previewIframe.className = "w-100 h-100 bn";
        previewContainer.appendChild(previewIframe);

        // Create HTML content for iframe
        const iframeDoc =
          previewIframe.contentDocument || previewIframe.contentWindow.document;
        const htmlContent =
          `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <` +
          `script src="/static/vendor/p5.js"></` +
          `script>
    <` +
          `script src="/static/vendor/p5.plotSvg.js"></` +
          `script>
    <style>
        body { margin: 0; padding: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <` +
          `script>
        p5.disableFriendlyErrors = true;
        ${code}
    </` +
          `script>
</body>
</html>`;

        iframeDoc.open();
        iframeDoc.write(htmlContent);
        iframeDoc.close();

        log("Preview updated", "success");
      }

      async function plotFromEditor() {
        const code = codeEditor
          ? codeEditor.getValue()
          : document.getElementById("codeEditor").value;

        try {
          log("Generating SVG...", "info");

          // Generate SVG using shared function
          const svgString = await generateSvgFromCode(code);

          currentSvg = svgString;
          // Update AlpineJS state
          const alpineData = getAlpineData();
          if (alpineData) {
            alpineData.currentSvg = svgString;
          }

          // Send to backend for plotting
          const layerInput = document.getElementById("layerInput");
          const penUp = parseInt(document.getElementById("penUp").value) || 70;
          const penDown =
            parseInt(document.getElementById("penDown").value) || 40;
          const speedUp =
            parseInt(document.getElementById("speedUp").value) || 75;
          const speedDown =
            parseInt(document.getElementById("speedDown").value) || 25;

          const payload = {
            svg: svgString,
            settings: {
              pen_up: penUp,
              pen_down: penDown,
              speed_up: speedUp,
              speed_down: speedDown,
            },
          };

          const layer = layerInput.value.trim();
          if (layer) {
            payload.layer = parseInt(layer);
          }

          log("Sending SVG to plotter...", "info");
          const response = await fetch("/plot", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          });
          const result = await response.json();

          if (result.success) {
            log(result.message || "Plot started successfully", "success");
          } else {
            const errorMsg = result.error || "Plot failed";
            log(`Plot failed: ${errorMsg}`, "error");
            const alpineData = getAlpineData();
            if (alpineData) {
              alpineData.showAlert(`Plot Failed: ${errorMsg}`, "error");
            }
          }
        } catch (error) {
          const errorMsg = error.message || "Plot error";
          log(`Error plotting: ${errorMsg}`, "error");
          console.error(error);
          const alpineData = getAlpineData();
          if (alpineData) {
            alpineData.showAlert(`Plot Error: ${errorMsg}`, "error");
          }
        }
      }

      async function exportSvg() {
        const code = codeEditor
          ? codeEditor.getValue()
          : document.getElementById("codeEditor").value;

        try {
          log("Generating SVG...", "info");

          // Generate SVG using shared function
          const svgString = await generateSvgFromCode(code);

          currentSvg = svgString;
          // Update AlpineJS state
          const alpineData = getAlpineData();
          if (alpineData) {
            alpineData.currentSvg = svgString;
          }

          // Download SVG directly
          const blob = new Blob([svgString], { type: "image/svg+xml" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "sketch.svg";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          log("SVG exported and downloaded successfully", "success");
        } catch (error) {
          log(`Error exporting SVG: ${error.message}`, "error");
          console.error(error);
        }
      }

      function downloadSvg() {
        if (!currentSvg) {
          log("No SVG to download. Please export SVG first.", "error");
          return;
        }

        const blob = new Blob([currentSvg], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "sketch.svg";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        log("SVG downloaded", "success");
      }
    </script>
  </body>
</html>
