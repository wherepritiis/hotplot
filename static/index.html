<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AxiDraw Control Panel</title>
    <!-- Tachyons CSS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/tachyons@4.12.0/css/tachyons.min.css"
    />
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="/static/vendor/codemirror/codemirror.css" />
    <!-- CodeMirror Isotope Theme -->
    <link rel="stylesheet" href="/static/vendor/codemirror/theme/isotope.css" />
    <!-- Custom Styles -->
    <link rel="stylesheet" href="/static/styles.css" />
    <!-- AlpineJS Data Component - Define before Alpine loads -->
    <script>
      // Define Alpine component data function
      const appDataDefinition = () => ({
        currentMode: "plot",
        logPanelOpen: false,
        connected: false,
        plotting: false,
        paused: false,
        commandHistory: [],
        currentSvg: null,
        alerts: [],

        switchMode(mode) {
          this.currentMode = mode;
        },
        toggleLogPanel() {
          this.logPanelOpen = !this.logPanelOpen;
        },
        showAlert(message, type = "error") {
          const alert = {
            id: Date.now() + Math.random(),
            message: message,
            type: type, // "error", "success", "info", "warning"
          };
          this.alerts.push(alert);
          
          // Auto-dismiss after 5 seconds for errors, 3 seconds for others
          const dismissTime = type === "error" ? 5000 : 3000;
          setTimeout(() => {
            this.dismissAlert(alert.id);
          }, dismissTime);
        },
        dismissAlert(id) {
          this.alerts = this.alerts.filter(alert => alert.id !== id);
        },
        async connect() {
          try {
            window.log("Connecting...", "info");
            const response = await fetch("/connect", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
            });
            const result = await response.json();
            if (result.success) {
              window.log(result.message || "Connected successfully", "success");
              this.connected = true;
            } else {
              const errorMsg = result.error || "Connection failed";
              window.log(`Connection failed: ${errorMsg}`, "error");
              this.showAlert(`Connection Failed: ${errorMsg}`, "error");
              this.connected = false;
            }
            await window.checkState();
          } catch (error) {
            const errorMsg = error.message || "Connection error";
            window.log(`Error connecting: ${errorMsg}`, "error");
            this.showAlert(`Connection Error: ${errorMsg}`, "error");
            this.connected = false;
          }
        },
        async disconnect() {
          try {
            window.log("Disconnecting...", "info");
            const response = await fetch("/disconnect", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
            });
            const result = await response.json();
            if (result.success) {
              window.log(
                result.message || "Disconnected successfully",
                "success"
              );
              this.connected = false;
            } else {
              const errorMsg = result.error || "Disconnect failed";
              window.log(`Disconnect failed: ${errorMsg}`, "error");
              this.showAlert(`Disconnect Failed: ${errorMsg}`, "error");
            }
            await window.checkState();
          } catch (error) {
            const errorMsg = error.message || "Disconnect error";
            window.log(`Error disconnecting: ${errorMsg}`, "error");
            this.showAlert(`Disconnect Error: ${errorMsg}`, "error");
          }
        },
        async sendCommand() {
          const commandInput = document.getElementById("commandInput");
          const command = commandInput.value.trim();
          if (!command) {
            window.log("Please enter a command", "error");
            return;
          }
          if (!this.connected) {
            window.log("Not connected. Please connect first.", "error");
            return;
          }
          try {
            window.log(`Sending command: ${command}`, "info");
            const response = await fetch("/cmd", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ command: command }),
            });
            const result = await response.json();
            if (result.success) {
              window.log(
                result.message || "Command executed successfully",
                "success"
              );
              this.addToHistory(command, result.message || "Success");
            } else {
              const errorMsg = result.error || "Command failed";
              window.log(`Command failed: ${errorMsg}`, "error");
              this.showAlert(`Command Failed: ${errorMsg}`, "error");
              this.addToHistory(command, `Error: ${errorMsg}`);
            }
            commandInput.value = "";
          } catch (error) {
            const errorMsg = error.message || "Command error";
            window.log(`Error sending command: ${errorMsg}`, "error");
            this.showAlert(`Command Error: ${errorMsg}`, "error");
            this.addToHistory(command, `Error: ${errorMsg}`);
          }
        },
        addToHistory(command, response) {
          this.commandHistory.push({
            command,
            response,
            timestamp: new Date(),
          });
        },
        async copySvg() {
          try {
            let svgToCopy =
              this.currentSvg ||
              (typeof currentSvg !== "undefined" ? currentSvg : null);
            
            // If no SVG is available, generate it from the code editor
            if (!svgToCopy) {
              window.log("Generating SVG from code...", "info");
              
              // Get code from editor
              const code = codeEditor
                ? codeEditor.getValue()
                : document.getElementById("codeEditor").value;
              
              // Generate SVG
              svgToCopy = await generateSvgFromCode(code);
              
              // Store the generated SVG
              currentSvg = svgToCopy;
              this.currentSvg = svgToCopy;
            }
            
            // Copy to clipboard
            await navigator.clipboard.writeText(svgToCopy);
            window.log("SVG copied to clipboard", "success");
          } catch (error) {
            window.log(`Error copying SVG: ${error.message}`, "error");
          }
        },
      });
    </script>
    <!-- AlpineJS - Load without defer to ensure proper initialization order -->
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <!-- Register Alpine data immediately after Alpine loads -->
    <script>
      // Register Alpine data component - Alpine is now loaded
      Alpine.data("appData", appDataDefinition);
    </script>
    <!-- p5.js and p5.plotSvg will be loaded dynamically in preview iframe -->
  </head>
  <body
    x-data="appData"
    class="sans-serif w-100 center pa3"
  >
    <div class="app-container">
    <!-- Header -->
    <header class="app-header">
      <!-- Logo: Hotplot with O as connect toggle, second O as status -->
      <div class="app-logo brand-wrap" aria-label="Hotplot">
        <span class="brand-letter brand-letter--h" aria-hidden="true">H</span>
        <span class="logo-toggle-wrap">
          <label class="logo-toggle" title="Connect">
            <input
              type="checkbox"
              id="logoConnectToggle"
              aria-label="Connect"
              :checked="connected"
              @change="connected ? disconnect() : connect()"
            />
            <span class="logo-toggle-track"><span class="logo-toggle-knob"></span></span>
          </label>
        </span>
        <span class="brand-letter brand-rest" aria-hidden="true">tpl</span>
        <span
          class="brand-status-o"
          :class="connected ? 'brand-status--connected' : 'brand-status--disconnected'"
          id="brandStatusO"
          aria-label="Connection status"
        ></span>
        <span class="brand-letter brand-rest" aria-hidden="true">t</span>
      </div>

      <!-- Mode Toggle Group (Center) -->
      <div class="mode-toggle-group">
        <div class="mode-toggle-container" id="toggleContainer">
          <div class="mode-toggle-slider-trail mode-toggle-slider-trail--1" id="toggleSliderTrail1" aria-hidden="true"></div>
          <div class="mode-toggle-slider-trail" id="toggleSliderTrail2" aria-hidden="true"></div>
          <div class="mode-toggle-slider" id="toggleSlider" aria-hidden="true"></div>
          <div class="toggle-option" id="toggleOptionPlot" :class="{ 'toggle-option--active': currentMode === 'plot' }">
            <div class="toggle-trail toggle-trail--1" id="toggleTrailPlot1" aria-hidden="true"></div>
            <div class="toggle-trail toggle-trail--2" id="toggleTrailPlot2" aria-hidden="true"></div>
            <button
              type="button"
              @click="switchMode('plot')"
              :class="currentMode === 'plot' ? 'mode-toggle-btn-active' : 'mode-toggle-btn-inactive'"
              class="mode-toggle-btn"
              id="btnPlot"
            >
              Plot mode
            </button>
          </div>
          <div class="toggle-option" id="toggleOptionInteractive" :class="{ 'toggle-option--active': currentMode === 'interactive' }">
            <div class="toggle-trail toggle-trail--1" id="toggleTrailInteractive1" aria-hidden="true"></div>
            <div class="toggle-trail toggle-trail--2" id="toggleTrailInteractive2" aria-hidden="true"></div>
            <button
              type="button"
              @click="switchMode('interactive')"
              :class="currentMode === 'interactive' ? 'mode-toggle-btn-active' : 'mode-toggle-btn-inactive'"
              class="mode-toggle-btn"
              id="btnInteractive"
            >
              Interactive mode
            </button>
          </div>
        </div>
      </div>

      <!-- Log (Right) -->
      <div class="flex items-center">
        <button
          @click="toggleLogPanel()"
          class="log-link"
        >
          Log
        </button>
      </div>
    </header>

    <!-- Alert Notifications -->
    <div class="alert-container" x-show="alerts.length > 0">
      <div class="alert-container-inner">
        <template x-for="alert in alerts" :key="alert.id">
          <div
            x-show="alerts.length > 0"
            x-transition:enter="transition ease-out duration-300"
            x-transition:enter-start="opacity-0 transform translate-y-[-10px]"
            x-transition:enter-end="opacity-100 transform translate-y-0"
            x-transition:leave="transition ease-in duration-200"
            x-transition:leave-start="opacity-100 transform translate-y-0"
            x-transition:leave-end="opacity-0 transform translate-y-[-10px]"
            :class="{
              'alert-error': alert.type === 'error',
              'alert-success': alert.type === 'success',
              'alert-info': alert.type === 'info',
              'alert-warning': alert.type === 'warning'
            }"
            class="alert"
          >
            <span x-text="alert.message" class="flex-auto pr2"></span>
            <button
              @click="dismissAlert(alert.id)"
              class="alert-dismiss"
              title="Dismiss"
            >
              ×
            </button>
          </div>
        </template>
      </div>
    </div>

    <!-- Plot Mode Content -->
    <div x-show="currentMode === 'plot'">
      <div class="plot-mode-layout">
        <!-- Top row: Editor | Preview (same height) -->
        <div class="plot-top-row flex">
          <div class="plot-editor-col w-50 pr2">
            <div class="perspective-box-container plot-editor-wrap mb3">
              <div class="perspective-box">
                <div class="box-face box-face-front"></div>
                <div class="box-face box-face-left"></div>
                <div class="box-content">
                  <div class="box-editor-container">
                    <textarea id="codeEditor" class="box-editor-textarea">function setup() {
  createCanvas(780, 560); // 8.125" x 5.83" at 96 dpi
  background(255);
  noFill();
}

function draw() {
  square(50, 100, 40);
}</textarea>
                  </div>
                </div>
                <div class="circle-container" id="circleContainer">
                  <div class="circle-trail circle-trail--1" id="previewTrail1" aria-hidden="true"></div>
                  <div class="circle-trail circle-trail--2" id="previewTrail2" aria-hidden="true"></div>
                  <div class="circle-element" id="circleElement" onclick="runPreview()">
                    <span class="circle-text">Preview</span>
                  </div>
                  <div class="curved-text" id="curvedText">
                    <svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                      <defs>
                        <path id="circle-path-p5js" d="M 100,15 A 85,85 0 0,1 185,100" fill="none"/>
                        <path id="circle-path-sketch" d="M 185,100 A 85,85 0 0,1 15,100" fill="none"/>
                      </defs>
                      <text font-size="18" fill="#F9A66C" letter-spacing="0.15em">
                        <textPath href="#circle-path-p5js" startOffset="0%">p 5 . j s</textPath>
                      </text>
                      <text font-size="18" fill="#F9A66C" letter-spacing="0.15em">
                        <textPath href="#circle-path-sketch" startOffset="0%">s k e t c h</textPath>
                      </text>
                    </svg>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="plot-preview-col w-50 pl2">
            <div class="flex items-center justify-end mb2">
              <div class="flex">
                <button @click="copySvg()" class="btn btn-icon mr2" title="Copy SVG">
                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect width="14" height="14" x="8" y="8" rx="2" ry="2"/>
                    <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>
                  </svg>
                </button>
                <button onclick="exportSvg()" class="btn btn-icon" title="Export SVG">
                  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 2v13"/>
                    <path d="m16 6-4-4-4 4"/>
                    <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/>
                  </svg>
                </button>
              </div>
            </div>
            <div class="preview-container-wrapper">
              <div class="preview-container plot-preview-wrap mb3" id="previewContainer">
                <div class="text-muted">Click the preview circle to see your sketch</div>
              </div>
              <!-- Bottom flap - positioned outside container -->
              <div class="preview-bottom-flap"></div>
              <!-- Copy SVG Button - positioned outside container to avoid clipping -->
              <div class="preview-copy-circle-container" id="previewCopyContainer">
                    <div class="preview-copy-circle-trail preview-copy-circle-trail--1" id="previewCopyTrail1" aria-hidden="true"></div>
                    <div class="preview-copy-circle-trail preview-copy-circle-trail--2" id="previewCopyTrail2" aria-hidden="true"></div>
                    <div class="preview-copy-circle-element" id="previewCopyElement" onclick="copySvg()">
                      <span class="preview-copy-circle-text">Copy</span>
                    </div>
                    <div class="preview-copy-curved-text" id="previewCopyCurved">
                      <svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                        <defs>
                          <path id="preview-path-copy-text" d="M 100,15 A 85,85 0 0,1 185,100" fill="none"/>
                          <path id="preview-path-svg-text" d="M 185,100 A 85,85 0 0,1 15,100" fill="none"/>
                        </defs>
                        <text font-size="18" fill="#577bff" letter-spacing="0.15em">
                          <textPath href="#preview-path-copy-text" startOffset="0%">c o p y</textPath>
                        </text>
                        <text font-size="18" fill="#577bff" letter-spacing="0.15em">
                          <textPath href="#preview-path-svg-text" startOffset="0%">s v g</textPath>
                        </text>
                  </svg>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Bottom row: SVG Text Area (left) | Plotter settings (right), Plot button below settings -->
        <div class="plot-bottom-row flex">
          <div class="plot-svg-col w-50 pr2">
            <div class="perspective-box-container svg-textarea-wrap">
              <div class="perspective-box">
                <div class="box-face box-face-front"></div>
                <div class="box-face box-face-top"></div>
                <div class="box-content">
                  <textarea
                    id="svgInput"
                    placeholder="Paste SVG content here..."
                    class="input-field input-field-textarea plot-svg-textarea"
                  ></textarea>
                </div>
              </div>
            </div>
          </div>
          <div class="plot-settings-col w-50 pl2">
            <div class="panel plot-settings-panel">
              <div class="panel-section">
                <label for="layerInput" class="input-label">Layer Number (optional)</label>
                <input type="number" id="layerInput" placeholder="Leave empty for all layers" class="input-field" />
              </div>
              <div class="panel-section">
                <div class="input-grid">
                  <div class="input-grid-item">
                    <label for="penUp" class="input-label">Pen Up Height</label>
                    <input type="number" id="penUp" value="70" min="0" max="100" class="input-field" />
                  </div>
                  <div class="input-grid-item">
                    <label for="penDown" class="input-label">Pen Down Height</label>
                    <input type="number" id="penDown" value="40" min="0" max="100" class="input-field" />
                  </div>
                </div>
              </div>
              <div class="panel-section">
                <div class="input-grid">
                  <div class="input-grid-item">
                    <label for="speedUp" class="input-label">Speed Up (%)</label>
                    <input type="number" id="speedUp" value="75" min="1" max="110" class="input-field" />
                  </div>
                  <div class="input-grid-item">
                    <label for="speedDown" class="input-label">Speed Down (%)</label>
                    <input type="number" id="speedDown" value="25" min="1" max="110" class="input-field" />
                  </div>
                </div>
              </div>
              <div class="panel-section plot-buttons-section">
                <button class="btn btn-success mr2" id="plotBtn" onclick="plotFromEditorOrSvg()">Plot</button>
                <button class="btn btn-primary mr2 hidden" id="resumeBtn" onclick="resumePlot()">Resume</button>
                <button class="btn btn-primary hidden" id="returnHomeBtn" onclick="returnHome()">Go to Home</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Exported SVG Container (hidden by default) -->
      <div class="panel hidden" id="exportedSvgContainer">
        <label for="exportedSvg" class="input-label"
          >Exported SVG</label
        >
        <textarea
          id="exportedSvg"
          readonly
          class="input-field input-field-textarea"
        ></textarea>
      </div>
    </div>

    <!-- Interactive Mode Content -->
    <div x-show="currentMode === 'interactive'">
      <div class="flex">
        <!-- Command Reference (Left) -->
        <div class="w-50 pr2">
          <div class="panel">
            <h2 class="panel-title">Command Reference</h2>
            <div class="command-reference">
              <div class="command-item">
                <div class="command-name">moveto x y</div>
                <div class="command-description">Absolute pen-up move to (x, y)</div>
              </div>
              <div class="command-item">
                <div class="command-name">lineto x y</div>
                <div class="command-description">Absolute pen-down move to (x, y)</div>
              </div>
              <div class="command-item">
                <div class="command-name">penup</div>
                <div class="command-description">Raise pen</div>
              </div>
              <div class="command-item">
                <div class="command-name">pendown</div>
                <div class="command-description">Lower pen</div>
              </div>
              <div class="command-item">
                <div class="command-name">home</div>
                <div class="command-description">Move to home position (0, 0)</div>
              </div>
            </div>
          </div>
        </div>

        <!-- REPL (Right) -->
        <div class="w-50 pl2">
          <div class="panel">
            <h2 class="panel-title">REPL</h2>
            <div class="panel-section">
              <div class="repl-input-container">
                <input
                  type="text"
                  id="commandInput"
                  placeholder="e.g., moveto 1 1"
                  @keydown.enter="sendCommand()"
                  class="input-field repl-input"
                />
                <button
                  class="btn btn-primary"
                  id="sendBtn"
                  @click="sendCommand()"
                  :disabled="!connected"
                >
                  Send
                </button>
              </div>
              <div class="repl-container">
                <template x-for="entry in commandHistory" :key="entry.timestamp">
                  <div class="repl-entry">
                    <div class="repl-command">
                      <span class="repl-command-prompt">&gt;</span>
                      <span x-text="entry.command"></span>
                    </div>
                    <div class="repl-response" x-text="entry.response"></div>
                  </div>
                </template>
                <div x-show="commandHistory.length === 0" class="repl-history-empty">
                  No commands yet. Enter a command above.
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Log Side Panel -->
    <div
      x-show="logPanelOpen"
      x-transition:enter="transition ease-out duration-300"
      x-transition:enter-start="translate-x-full"
      x-transition:enter-end="translate-x-0"
      x-transition:leave="transition ease-in duration-300"
      x-transition:leave-start="translate-x-0"
      x-transition:leave-end="translate-x-full"
      class="log-panel"
    >
      <!-- Panel Header -->
      <div class="log-panel-header">
        <h2 class="log-panel-title">Log</h2>
        <button
          @click="toggleLogPanel()"
          class="log-panel-close"
          title="Close"
        >
          ✕
        </button>
      </div>

      <!-- Log Content Area -->
      <div
        id="logArea"
        class="log-panel-content"
      >
        <!-- Log entries will be inserted here -->
      </div>
    </div>

    <!-- Backdrop/Overlay -->
    <div
      x-show="logPanelOpen"
      @click="toggleLogPanel()"
      x-transition:enter="transition ease-out duration-300"
      x-transition:enter-start="opacity-0"
      x-transition:enter-end="opacity-100"
      x-transition:leave="transition ease-in duration-300"
      x-transition:leave-start="opacity-100"
      x-transition:leave-end="opacity-0"
      class="log-backdrop"
    ></div>

    <script>
      // Make functions globally accessible for AlpineJS
      window.connected = false;

      // Make log function globally accessible
      window.log = function (message, type = "info") {
        const logArea = document.getElementById("logArea");
        if (!logArea) return;
        const timestamp = new Date().toLocaleTimeString();
        const entry = document.createElement("div");
        entry.className = `log-entry ${type}`;
        entry.textContent = `[${timestamp}] ${message}`;
        logArea.appendChild(entry);
        logArea.scrollTop = logArea.scrollHeight;
      };

      // Alias for backward compatibility
      function log(message, type = "info") {
        window.log(message, type);
      }

      // Get AlpineJS component instance
      function getAlpineData() {
        return Alpine.$data(document.querySelector("[x-data]"));
      }

      function updateState(state) {
        const alpineData = getAlpineData();
        if (alpineData) {
          // Update AlpineJS reactive properties
          alpineData.connected = state.connected || false;
          alpineData.plotting = state.plotting || false;
          alpineData.paused = state.paused || false;
        }

        // Update global connected state for backward compatibility
        window.connected = state.connected;

        // Update plot button states (only if buttons exist - they're in Plot Mode)
        const plotBtn = document.getElementById("plotBtn");
        const resumeBtn = document.getElementById("resumeBtn");
        const returnHomeBtn = document.getElementById("returnHomeBtn");

        if (plotBtn && resumeBtn && returnHomeBtn) {
          const plotting = state.plotting || false;
          const paused = state.paused || false;

          // Plot button: enabled when not plotting and not paused
          if (!plotting && !paused) {
            plotBtn.disabled = false;
          } else {
            plotBtn.disabled = true;
          }

          // Resume button: visible only when paused
          if (paused) {
            resumeBtn.classList.remove("hidden");
          } else {
            resumeBtn.classList.add("hidden");
          }

          // Return Home button: visible only when paused (after physical pause button)
          if (paused) {
            returnHomeBtn.classList.remove("hidden");
          } else {
            returnHomeBtn.classList.add("hidden");
          }
        }

        if (state.error) {
          window.log(`State error: ${state.error}`, "error");
        }
      }

      // Make checkState globally accessible
      window.checkState = async function () {
        try {
          const response = await fetch("/state");
          const state = await response.json();
          updateState(state);
        } catch (error) {
          window.log(`Error checking state: ${error.message}`, "error");
        }
      };

      // Alias for backward compatibility
      async function checkState() {
        await window.checkState();
      }

      // Legacy functions for backward compatibility (now call AlpineJS methods)
      async function connect() {
        const alpineData = getAlpineData();
        if (alpineData && alpineData.connect) {
          await alpineData.connect();
        }
      }

      async function disconnect() {
        const alpineData = getAlpineData();
        if (alpineData && alpineData.disconnect) {
          await alpineData.disconnect();
        }
      }

      function handleKeyPress(event) {
        // Handled by AlpineJS @keydown.enter now
      }

      // Smart plot function: plots from SVG text area if it has content, otherwise from editor
      async function plotFromEditorOrSvg() {
        const svgInput = document.getElementById("svgInput");
        const svgText = svgInput ? svgInput.value.trim() : "";

        if (svgText) {
          // Plot from SVG text area
          await plot();
        } else {
          // Plot from editor
          await plotFromEditor();
        }
      }

      async function plot() {
        const svgInput = document.getElementById("svgInput");
        const svg = svgInput.value.trim();

        if (!svg) {
          log("Please paste SVG content", "error");
          return;
        }

        const layerInput = document.getElementById("layerInput");
        const penUp = parseInt(document.getElementById("penUp").value) || 70;
        const penDown =
          parseInt(document.getElementById("penDown").value) || 40;
        const speedUp =
          parseInt(document.getElementById("speedUp").value) || 75;
        const speedDown =
          parseInt(document.getElementById("speedDown").value) || 25;

        const payload = {
          svg: svg,
          settings: {
            pen_up: penUp,
            pen_down: penDown,
            speed_up: speedUp,
            speed_down: speedDown,
          },
        };

        const layer = layerInput.value.trim();
        if (layer) {
          payload.layer = parseInt(layer);
        }

        try {
          log("Starting plot...", "info");
          const response = await fetch("/plot", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          });
          const result = await response.json();

          if (result.success) {
            log(result.message || "Plot completed successfully", "success");
          } else {
            const errorMsg = result.error || "Plot failed";
            log(`Plot failed: ${errorMsg}`, "error");
            const alpineData = getAlpineData();
            if (alpineData) {
              alpineData.showAlert(`Plot Failed: ${errorMsg}`, "error");
            }
          }
        } catch (error) {
          const errorMsg = error.message || "Plot error";
          log(`Error plotting: ${errorMsg}`, "error");
          const alpineData = getAlpineData();
          if (alpineData) {
            alpineData.showAlert(`Plot Error: ${errorMsg}`, "error");
          }
        }
      }

      async function resumePlot() {
        try {
          log("Resuming plot...", "info");
          const response = await fetch("/resume", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
          });
          const result = await response.json();

          if (result.success) {
            log(result.message || "Plot resumed successfully", "success");
          } else {
            const errorMsg = result.error || "Resume failed";
            log(`Resume failed: ${errorMsg}`, "error");
            const alpineData = getAlpineData();
            if (alpineData) {
              alpineData.showAlert(`Resume Failed: ${errorMsg}`, "error");
            }
          }

          await checkState();
        } catch (error) {
          const errorMsg = error.message || "Resume error";
          log(`Error resuming plot: ${errorMsg}`, "error");
          const alpineData = getAlpineData();
          if (alpineData) {
            alpineData.showAlert(`Resume Error: ${errorMsg}`, "error");
          }
        }
      }

      async function returnHome() {
        try {
          log("Returning to home corner...", "info");
          const response = await fetch("/home", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
          });
          const result = await response.json();

          if (result.success) {
            log(result.message || "Returned to home successfully", "success");
          } else {
            log(`Return home failed: ${result.error}`, "error");
          }

          await checkState();
        } catch (error) {
          log(`Error returning home: ${error.message}`, "error");
        }
      }

      // Check state on page load
      checkState();

      // Poll state every 1 second (more frequent to catch pause state changes)
      setInterval(checkState, 1000);

      // Editor functionality
      let codeEditor;
      let previewIframe = null;
      let currentSvg = null;
      let defaultCode = `function setup() {
  createCanvas(780, 560); // 8.125" x 5.83" at 96 dpi
  background(255);
  noFill();
}

function draw() {
  square(50, 100, 40);
}`;

      // Shared SVG generation function
      async function generateSvgFromCode(code) {
        if (!code.trim()) {
          throw new Error("Please enter some code");
        }

        // Create a temporary iframe to generate SVG
        const tempIframe = document.createElement("iframe");
        tempIframe.style.display = "none";
        document.body.appendChild(tempIframe);

        const iframeWindow = tempIframe.contentWindow;
        const iframeDoc = tempIframe.contentDocument;

        // Wait for iframe to load
        await new Promise((resolve) => {
          tempIframe.onload = resolve;
          iframeDoc.open();
          iframeDoc.write(
            `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <` +
              `script src="/static/vendor/p5.js"></` +
              `script>
    <` +
              `script src="/static/vendor/p5.plotSvg.js"></` +
              `script>
</head>
<body>
    <` +
              `script>
        p5.disableFriendlyErrors = true;
        let svgResult = null;
        
        // User code defines setup() and draw() globally
        ${code}
        
        // Wait for p5 to initialize, then capture SVG
        function captureSvg() {
            if (typeof setup === 'function' || typeof draw === 'function') {
                // Run setup first to create canvas
                if (typeof setup === 'function') {
                    setup();
                }
                
                // Get canvas dimensions after setup runs
                let canvasWidth = 780; // default fallback
                let canvasHeight = 560; // default fallback
                
                // Try multiple methods to get canvas dimensions
                if (typeof width !== 'undefined' && typeof height !== 'undefined') {
                    canvasWidth = width;
                    canvasHeight = height;
                } else {
                    // Try to find the canvas element
                    const canvas = document.querySelector('canvas');
                    if (canvas) {
                        canvasWidth = canvas.width;
                        canvasHeight = canvas.height;
                    }
                }
                
                // Set SVG document size to match canvas exactly (ensures coordinate mapping)
                setSvgDocumentSize(canvasWidth, canvasHeight);
                // Set resolution to 96 DPI (matches p5.plotSvg default and pyaxidraw inches)
                setSvgResolutionDPI(96);
                
                // Use window as the instance (works in global mode)
                beginRecordSvg(window, null);
                // Re-run setup and draw to capture SVG
                if (typeof setup === 'function') setup();
                if (typeof draw === 'function') draw();
                svgResult = endRecordSvg();
                window.parent.postMessage({type: 'svgResult', svg: svgResult}, '*');
            } else {
                window.parent.postMessage({type: 'svgError', error: 'No setup() or draw() function found'}, '*');
            }
        }
        
        // Wait a bit for p5.js library to load and initialize
        setTimeout(captureSvg, 300);
    </` +
              `script>
</body>
</html>`
          );
          iframeDoc.close();
        });

        // Wait for SVG result via postMessage
        const svgString = await new Promise((resolve, reject) => {
          const messageHandler = (event) => {
            if (event.data.type === "svgResult") {
              window.removeEventListener("message", messageHandler);
              document.body.removeChild(tempIframe);
              resolve(event.data.svg);
            } else if (event.data.type === "svgError") {
              window.removeEventListener("message", messageHandler);
              document.body.removeChild(tempIframe);
              reject(new Error(event.data.error));
            }
          };
          window.addEventListener("message", messageHandler);

          // Timeout after 5 seconds
          setTimeout(() => {
            window.removeEventListener("message", messageHandler);
            if (document.body.contains(tempIframe)) {
              document.body.removeChild(tempIframe);
            }
            reject(new Error("SVG generation timeout"));
          }, 5000);
        });

        if (!svgString) {
          throw new Error("Failed to generate SVG");
        }

        return svgString;
      }

      // Initialize CodeMirror when page loads
      window.addEventListener("DOMContentLoaded", function () {
        // Load CodeMirror script dynamically
        const codemirrorScript = document.createElement("script");
        codemirrorScript.src = "/static/vendor/codemirror/codemirror.js";
        codemirrorScript.onload = function () {
          const jsModeScript = document.createElement("script");
          jsModeScript.src =
            "/static/vendor/codemirror/mode/javascript/javascript.js";
          jsModeScript.onload = function () {
            const textarea = document.getElementById("codeEditor");
            // Ensure textarea has the value before CodeMirror reads it
            if (textarea.value !== defaultCode) {
              textarea.value = defaultCode;
            }
            codeEditor = CodeMirror.fromTextArea(textarea, {
              lineNumbers: true,
              mode: "javascript",
              theme: "isotope",
              indentUnit: 2,
              lineWrapping: true,
            });
            // Set value immediately after creation
            setTimeout(() => {
              codeEditor.setValue(defaultCode);
            }, 0);
          };
          document.head.appendChild(jsModeScript);
        };
        document.head.appendChild(codemirrorScript);
      });

      function runPreview() {
        const code = codeEditor
          ? codeEditor.getValue()
          : document.getElementById("codeEditor").value;

        if (!code.trim()) {
          log("Please enter some code", "error");
          return;
        }

        // Create or update preview iframe
        const previewContainer = document.getElementById("previewContainer");

        // Remove placeholder message if it exists
        const placeholder = previewContainer.querySelector("div.text-muted");
        if (
          placeholder &&
          placeholder.textContent.includes("preview circle")
        ) {
          previewContainer.removeChild(placeholder);
        }

        // Remove existing iframe if it exists
        if (previewIframe) {
          previewContainer.removeChild(previewIframe);
        }

        previewIframe = document.createElement("iframe");
        previewIframe.id = "previewFrame";
        previewIframe.className = "w-100 h-100 bn";
        previewContainer.appendChild(previewIframe);

        // Create HTML content for iframe
        const iframeDoc =
          previewIframe.contentDocument || previewIframe.contentWindow.document;
        const htmlContent =
          `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <` +
          `script src="/static/vendor/p5.js"></` +
          `script>
    <` +
          `script src="/static/vendor/p5.plotSvg.js"></` +
          `script>
    <style>
        body {
          margin: 0;
          padding: 0;
          background-color: #ffffff;
          background-image: radial-gradient(
            circle at center,
            rgba(166, 1, 244, 0.2) 1px,
            transparent 1px
          );
          background-size: 20px 20px;
        }
        canvas { 
          display: block;
        }
    </style>
</head>
<body>
    <` +
          `script>
        p5.disableFriendlyErrors = true;
        ${code}
    </` +
          `script>
    <` +
          `script>
        (function() {
          function addGridOverlay() {
            var overlay = document.createElement("div");
            overlay.setAttribute("aria-hidden", "true");
            overlay.style.cssText = "position:fixed;inset:0;z-index:9999;pointer-events:none;background-color:transparent;background-image:radial-gradient(circle at center, rgba(166,1,244,0.2) 1px, transparent 1px);background-size:20px 20px;";
            document.body.appendChild(overlay);
          }
          function tryAddOverlay() {
            if (document.querySelector("canvas")) {
              addGridOverlay();
              return true;
            }
            return false;
          }
          if (tryAddOverlay()) return;
          var obs = new MutationObserver(function() {
            if (tryAddOverlay()) obs.disconnect();
          });
          obs.observe(document.body, { childList: true, subtree: true });
          setTimeout(function() {
            obs.disconnect();
            tryAddOverlay();
          }, 2000);
        })();
    </` +
          `script>
</body>
</html>`;

        iframeDoc.open();
        iframeDoc.write(htmlContent);
        iframeDoc.close();

        log("Preview updated", "success");
      }

      async function plotFromEditor() {
        const code = codeEditor
          ? codeEditor.getValue()
          : document.getElementById("codeEditor").value;

        try {
          log("Generating SVG...", "info");

          // Generate SVG using shared function
          const svgString = await generateSvgFromCode(code);

          currentSvg = svgString;
          // Update AlpineJS state
          const alpineData = getAlpineData();
          if (alpineData) {
            alpineData.currentSvg = svgString;
          }

          // Send to backend for plotting
          const layerInput = document.getElementById("layerInput");
          const penUp = parseInt(document.getElementById("penUp").value) || 70;
          const penDown =
            parseInt(document.getElementById("penDown").value) || 40;
          const speedUp =
            parseInt(document.getElementById("speedUp").value) || 75;
          const speedDown =
            parseInt(document.getElementById("speedDown").value) || 25;

          const payload = {
            svg: svgString,
            settings: {
              pen_up: penUp,
              pen_down: penDown,
              speed_up: speedUp,
              speed_down: speedDown,
            },
          };

          const layer = layerInput.value.trim();
          if (layer) {
            payload.layer = parseInt(layer);
          }

          log("Sending SVG to plotter...", "info");
          const response = await fetch("/plot", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(payload),
          });
          const result = await response.json();

          if (result.success) {
            log(result.message || "Plot started successfully", "success");
          } else {
            const errorMsg = result.error || "Plot failed";
            log(`Plot failed: ${errorMsg}`, "error");
            const alpineData = getAlpineData();
            if (alpineData) {
              alpineData.showAlert(`Plot Failed: ${errorMsg}`, "error");
            }
          }
        } catch (error) {
          const errorMsg = error.message || "Plot error";
          log(`Error plotting: ${errorMsg}`, "error");
          console.error(error);
          const alpineData = getAlpineData();
          if (alpineData) {
            alpineData.showAlert(`Plot Error: ${errorMsg}`, "error");
          }
        }
      }

      // Global copySvg function that can be called from onclick handlers
      async function copySvg() {
        try {
          // Try to get SVG from Alpine data first
          const alpineData = getAlpineData();
          let svgToCopy = null;
          
          if (alpineData && alpineData.currentSvg) {
            svgToCopy = alpineData.currentSvg;
          } else if (typeof currentSvg !== "undefined" && currentSvg) {
            svgToCopy = currentSvg;
          }
          
          // If no SVG is available, generate it from the code editor
          if (!svgToCopy) {
            log("Generating SVG from code...", "info");
            
            // Get code from editor
            const code = codeEditor
              ? codeEditor.getValue()
              : document.getElementById("codeEditor").value;
            
            // Generate SVG
            svgToCopy = await generateSvgFromCode(code);
            
            // Store the generated SVG
            currentSvg = svgToCopy;
            if (alpineData) {
              alpineData.currentSvg = svgToCopy;
            }
          }
          
          // Copy to clipboard
          await navigator.clipboard.writeText(svgToCopy);
          log("SVG copied to clipboard", "success");
          
          // Show alert
          const alertAlpineData = getAlpineData();
          if (alertAlpineData) {
            alertAlpineData.showAlert("SVG copied to clipboard", "success");
          }
        } catch (error) {
          log(`Error copying SVG: ${error.message}`, "error");
          const alertAlpineData = getAlpineData();
          if (alertAlpineData) {
            alertAlpineData.showAlert(`Error copying SVG: ${error.message}`, "error");
          }
        }
      }

      async function exportSvg() {
        const code = codeEditor
          ? codeEditor.getValue()
          : document.getElementById("codeEditor").value;

        try {
          log("Generating SVG...", "info");

          // Generate SVG using shared function
          const svgString = await generateSvgFromCode(code);

          currentSvg = svgString;
          // Update AlpineJS state
          const alpineData = getAlpineData();
          if (alpineData) {
            alpineData.currentSvg = svgString;
          }

          // Download SVG directly
          const blob = new Blob([svgString], { type: "image/svg+xml" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "sketch.svg";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          log("SVG exported and downloaded successfully", "success");
        } catch (error) {
          log(`Error exporting SVG: ${error.message}`, "error");
          console.error(error);
        }
      }

      function downloadSvg() {
        if (!currentSvg) {
          log("No SVG to download. Please export SVG first.", "error");
          return;
        }

        const blob = new Blob([currentSvg], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "sketch.svg";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        log("SVG downloaded", "success");
      }
    </script>
    </div>

    <!-- Preview circle: magnetic + trail + curved text rotation -->
    <script>
      (function () {
        const getMousePos = (e) => ({ x: e.clientX, y: e.clientY });
        const distance = (x1, y1, x2, y2) => Math.hypot(x1 - x2, y1 - y2);
        const lerp = (a, b, n) => (1 - n) * a + n * b;
        let mousepos = { x: 0, y: 0 };
        window.addEventListener("mousemove", (ev) => { mousepos = getMousePos(ev); });
        const container = document.getElementById("circleContainer");
        const el = document.getElementById("circleElement");
        const trail1 = document.getElementById("previewTrail1");
        const trail2 = document.getElementById("previewTrail2");
        const curvedEl = document.getElementById("curvedText");
        if (!container || !el) return;
        let rect = el.getBoundingClientRect();
        let hoverCurved = false;
        let curveAngle = { previous: 0, current: 0, amt: 0.03 };
        container.addEventListener("mouseenter", () => { hoverCurved = true; });
        container.addEventListener("mouseleave", () => { hoverCurved = false; });
        const distanceToTrigger = () => rect.width * 1.5;
        const rendered = {
          tx: { previous: 0, current: 0, amt: 0.12 }, ty: { previous: 0, current: 0, amt: 0.12 },
          t2x: { previous: 0, current: 0, amt: 0.07 }, t2y: { previous: 0, current: 0, amt: 0.07 },
          t1x: { previous: 0, current: 0, amt: 0.04 }, t1y: { previous: 0, current: 0, amt: 0.04 },
          tx2: { previous: 0, current: 0, amt: 0.06 }, ty2: { previous: 0, current: 0, amt: 0.06 }
        };
        function updateRect() { rect = el.getBoundingClientRect(); }
        window.addEventListener("resize", updateRect);
        function render() {
          updateRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          const d = distance(mousepos.x, mousepos.y, centerX, centerY);
          const trigger = distanceToTrigger();
          let x = 0, y = 0;
          if (d < trigger) {
            x = (mousepos.x - centerX) * 0.3;
            y = (mousepos.y - centerY) * 0.3;
          }
          rendered.tx.current = rendered.t2x.current = rendered.t1x.current = rendered.tx2.current = x;
          rendered.ty.current = rendered.t2y.current = rendered.t1y.current = rendered.ty2.current = y;
          curveAngle.current = hoverCurved ? 360 : 0;
          curveAngle.previous = lerp(curveAngle.previous, curveAngle.current, curveAngle.amt);
          for (const key of Object.keys(rendered)) {
            const r = rendered[key];
            r.previous = lerp(r.previous, r.current, r.amt);
          }
          trail1.style.transform = "translate3d(" + rendered.t1x.previous + "px," + rendered.t1y.previous + "px,0)";
          trail2.style.transform = "translate3d(" + rendered.t2x.previous + "px," + rendered.t2y.previous + "px,0)";
          el.style.transform = "translate3d(" + rendered.tx.previous + "px," + rendered.ty.previous + "px,0)";
          curvedEl.style.transform = "translate3d(" + (rendered.tx2.previous * 0.5) + "px," + (rendered.ty2.previous * 0.5) + "px,0) rotate(" + curveAngle.previous + "deg)";
          requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
      })();
    </script>

    <!-- Preview Copy Button: magnetic + trail + curved text rotation -->
    <script>
      (function () {
        const getMousePos = (e) => ({ x: e.clientX, y: e.clientY });
        const distance = (x1, y1, x2, y2) => Math.hypot(x1 - x2, y1 - y2);
        const lerp = (a, b, n) => (1 - n) * a + n * b;
        let mousepos = { x: 0, y: 0 };
        window.addEventListener("mousemove", (ev) => { mousepos = getMousePos(ev); });
        const container = document.getElementById("previewCopyContainer");
        const el = document.getElementById("previewCopyElement");
        const trail1 = document.getElementById("previewCopyTrail1");
        const trail2 = document.getElementById("previewCopyTrail2");
        const curvedEl = document.getElementById("previewCopyCurved");
        if (!container || !el) return;
        let rect = el.getBoundingClientRect();
        let hoverCurved = false;
        let curveAngle = { previous: 0, current: 0, amt: 0.03 };
        container.addEventListener("mouseenter", () => { hoverCurved = true; });
        container.addEventListener("mouseleave", () => { hoverCurved = false; });
        const distanceToTrigger = () => rect.width * 1.5;
        const rendered = {
          tx: { previous: 0, current: 0, amt: 0.12 }, ty: { previous: 0, current: 0, amt: 0.12 },
          t2x: { previous: 0, current: 0, amt: 0.07 }, t2y: { previous: 0, current: 0, amt: 0.07 },
          t1x: { previous: 0, current: 0, amt: 0.04 }, t1y: { previous: 0, current: 0, amt: 0.04 },
          tx2: { previous: 0, current: 0, amt: 0.06 }, ty2: { previous: 0, current: 0, amt: 0.06 }
        };
        function updateRect() { rect = el.getBoundingClientRect(); }
        window.addEventListener("resize", updateRect);
        function render() {
          updateRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          const d = distance(mousepos.x, mousepos.y, centerX, centerY);
          const trigger = distanceToTrigger();
          let x = 0, y = 0;
          if (d < trigger) {
            x = (mousepos.x - centerX) * 0.3;
            y = (mousepos.y - centerY) * 0.3;
          }
          rendered.tx.current = rendered.t2x.current = rendered.t1x.current = rendered.tx2.current = x;
          rendered.ty.current = rendered.t2y.current = rendered.t1y.current = rendered.ty2.current = y;
          curveAngle.current = hoverCurved ? 360 : 0;
          curveAngle.previous = lerp(curveAngle.previous, curveAngle.current, curveAngle.amt);
          for (const key of Object.keys(rendered)) {
            const r = rendered[key];
            r.previous = lerp(r.previous, r.current, r.amt);
          }
          trail1.style.transform = "translate3d(" + rendered.t1x.previous + "px," + rendered.t1y.previous + "px,0)";
          trail2.style.transform = "translate3d(" + rendered.t2x.previous + "px," + rendered.t2y.previous + "px,0)";
          el.style.transform = "translate3d(" + rendered.tx.previous + "px," + rendered.ty.previous + "px,0)";
          curvedEl.style.transform = "translate3d(" + (rendered.tx2.previous * 0.5) + "px," + (rendered.ty2.previous * 0.5) + "px,0) rotate(" + curveAngle.previous + "deg)";
          requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
      })();
    </script>

    <!-- Mode toggle: trail on hover (active only) + slider trail -->
    <script>
      (function () {
        const getMousePos = (e) => ({ x: e.clientX, y: e.clientY });
        const distance = (x1, y1, x2, y2) => Math.hypot(x1 - x2, y1 - y2);
        const lerp = (a, b, n) => (1 - n) * a + n * b;
        let mousepos = { x: 0, y: 0 };
        window.addEventListener("mousemove", (ev) => { mousepos = getMousePos(ev); });
        const slider = document.getElementById("toggleSlider");
        const sliderTrail1 = document.getElementById("toggleSliderTrail1");
        const sliderTrail2 = document.getElementById("toggleSliderTrail2");
        const optionPlot = document.getElementById("toggleOptionPlot");
        const optionInteractive = document.getElementById("toggleOptionInteractive");
        const trailPlot1 = document.getElementById("toggleTrailPlot1");
        const trailPlot2 = document.getElementById("toggleTrailPlot2");
        const trailInteractive1 = document.getElementById("toggleTrailInteractive1");
        const trailInteractive2 = document.getElementById("toggleTrailInteractive2");
        if (!slider || !optionPlot) return;
        let hoveredOption = null;
        optionPlot.addEventListener("mouseenter", () => { hoveredOption = "plot"; });
        optionPlot.addEventListener("mouseleave", () => { hoveredOption = null; });
        optionInteractive.addEventListener("mouseenter", () => { hoveredOption = "interactive"; });
        optionInteractive.addEventListener("mouseleave", () => { hoveredOption = null; });
        const strength = 0.3, triggerFactor = 1.5;
        const plotRendered = { t1x: { previous: 0, current: 0, amt: 0.04 }, t1y: { previous: 0, current: 0, amt: 0.04 }, t2x: { previous: 0, current: 0, amt: 0.07 }, t2y: { previous: 0, current: 0, amt: 0.07 } };
        const interactiveRendered = { t1x: { previous: 0, current: 0, amt: 0.04 }, t1y: { previous: 0, current: 0, amt: 0.04 }, t2x: { previous: 0, current: 0, amt: 0.07 }, t2y: { previous: 0, current: 0, amt: 0.07 } };
        const sliderPos = { main: { previous: 0, current: 0, amt: 0.08 }, trail2: { previous: 0, current: 0, amt: 0.05 }, trail1: { previous: 0, current: 0, amt: 0.025 } };
        function updateToggleTrails() {
          var currentMode = (document.querySelector("#toggleOptionPlot.toggle-option--active") ? "plot" : "interactive");
          var sliderTarget = currentMode === "plot" ? 0 : 1;
          function runOption(option, trail1El, trail2El, state, isHovered) {
            trail1El.classList.toggle("toggle-trail--visible", isHovered);
            trail2El.classList.toggle("toggle-trail--visible", isHovered);
            var x = 0, y = 0;
            if (isHovered) {
              var r = option.getBoundingClientRect();
              var centerX = r.left + r.width / 2, centerY = r.top + r.height / 2;
              var d = distance(mousepos.x, mousepos.y, centerX, centerY);
              if (d < r.width * triggerFactor) {
                x = (mousepos.x - centerX) * strength;
                y = (mousepos.y - centerY) * strength;
              }
            }
            state.t1x.current = state.t2x.current = x;
            state.t1y.current = state.t2y.current = y;
            for (var k in state) { var s = state[k]; s.previous = lerp(s.previous, s.current, s.amt); }
            trail1El.style.transform = "translate3d(" + state.t1x.previous + "px," + state.t1y.previous + "px,0)";
            trail2El.style.transform = "translate3d(" + state.t2x.previous + "px," + state.t2y.previous + "px,0)";
          }
          runOption(optionPlot, trailPlot1, trailPlot2, plotRendered, hoveredOption === "plot" && currentMode === "plot");
          runOption(optionInteractive, trailInteractive1, trailInteractive2, interactiveRendered, hoveredOption === "interactive" && currentMode === "interactive");
          sliderPos.main.current = sliderPos.trail2.current = sliderPos.trail1.current = sliderTarget;
          for (var k of ["main", "trail2", "trail1"]) { var s = sliderPos[k]; s.previous = lerp(s.previous, s.current, s.amt); }
          var tx = function (v) { return "translateX(" + (v * 100) + "%)"; };
          sliderTrail1.style.transform = tx(sliderPos.trail1.previous);
          sliderTrail2.style.transform = tx(sliderPos.trail2.previous);
          slider.style.transform = tx(sliderPos.main.previous);
          requestAnimationFrame(updateToggleTrails);
        }
        requestAnimationFrame(updateToggleTrails);
      })();
    </script>
  </body>
</html>
